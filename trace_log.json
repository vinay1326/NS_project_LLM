{
    "user_prompt": "list main NS topics",
    "query_embedding": [
        [
            0.0841454342007637,
            -0.08002275973558426,
            -0.030212759971618652,
            -2.275621227454394e-05,
            0.05743444710969925,
            0.05695898458361626,
            0.05183801427483559,
            -0.01172685157507658,
            -0.07420164346694946,
            0.06748687475919724,
            -0.05829113721847534,
            -0.004018365405499935,
            -0.08558473736047745,
            0.05035356059670448,
            -0.05282633751630783,
            -0.029038621112704277,
            -0.022234931588172913,
            0.005388513207435608,
            0.025983691215515137,
            -0.040635813027620316,
            -0.011826050467789173,
            0.100441113114357,
            0.01974284090101719,
            0.009380420669913292,
            -0.04415035620331764,
            0.05229589715600014,
            -0.01494404673576355,
            -0.029315870255231857,
            -0.020305518060922623,
            -0.012729237787425518,
            0.03226353973150253,
            0.07336580008268356,
            0.08360473811626434,
            0.044911932200193405,
            -0.013631127774715424,
            -0.03823661804199219,
            -0.002944964449852705,
            0.00025685172295197845,
            0.007991650141775608,
            -0.00280083529651165,
            -0.004820611327886581,
            0.036919645965099335,
            0.03277946636080742,
            0.04615934193134308,
            0.011060738004744053,
            0.026145707815885544,
            -0.044225312769412994,
            -0.026441579684615135,
            0.07026659697294235,
            0.05218347907066345,
            0.005013472866266966,
            -0.07991033792495728,
            -0.07735990732908249,
            0.08284764736890793,
            0.05589869245886803,
            0.04350220412015915,
            -0.04628746584057808,
            -0.026145663112401962,
            0.023930782452225685,
            0.024417303502559662,
            -0.01484577264636755,
            0.05395892262458801,
            -0.028326841071248055,
            -0.039080969989299774,
            0.09140802919864655,
            -0.05755472183227539,
            -0.01741899736225605,
            0.09638362377882004,
            0.005297896917909384,
            0.02657463774085045,
            0.007319954689592123,
            0.00807796511799097,
            0.019019342958927155,
            -0.0458679161965847,
            0.006308380048722029,
            -0.008764700032770634,
            0.02726532332599163,
            -0.026706118136644363,
            -0.07825917750597,
            -0.10159941762685776,
            -0.026886291801929474,
            0.012471921741962433,
            0.02512439712882042,
            0.01229195948690176,
            0.008890802040696144,
            0.012671427801251411,
            -0.01809234730899334,
            -0.07420454174280167,
            -0.11941583454608917,
            -0.03600633516907692,
            -0.04844645410776138,
            -0.06301766633987427,
            0.11608191579580307,
            -0.008892600424587727,
            -0.018097858875989914,
            0.009274122305214405,
            0.04939842224121094,
            -0.08666946738958359,
            0.025904729962348938,
            0.052690811455249786,
            -0.015483411960303783,
            -0.04377435892820358,
            0.020208852365612984,
            0.0026289871893823147,
            -0.04188487306237221,
            -0.041341014206409454,
            0.04293808713555336,
            -0.025845393538475037,
            -0.04546985402703285,
            0.045683376491069794,
            -0.036015693098306656,
            0.1422695368528366,
            -0.053076162934303284,
            -0.045751072466373444,
            0.06669529527425766,
            -0.10482490807771683,
            0.16731372475624084,
            0.008732105605304241,
            0.023087915033102036,
            0.05110424757003784,
            -0.05360819399356842,
            0.012763984501361847,
            -0.006138090509921312,
            0.0028258583042770624,
            -0.029508516192436218,
            -0.024177175015211105,
            -0.043836452066898346,
            -1.9413584914127707e-33,
            0.030335603281855583,
            -0.10512640327215195,
            0.024365704506635666,
            0.03098369762301445,
            -0.06944829970598221,
            0.01569984294474125,
            0.035293661057949066,
            0.003237413475289941,
            0.06698879599571228,
            -0.006266525946557522,
            -0.010661167092621326,
            0.10772284865379333,
            -0.004419192671775818,
            -0.012682219035923481,
            0.06949339061975479,
            -0.055950917303562164,
            0.0100787952542305,
            0.039976414293050766,
            -0.05834108218550682,
            -0.043666139245033264,
            -0.08579690754413605,
            0.057494159787893295,
            -0.005641926545649767,
            -0.049187250435352325,
            0.047425683587789536,
            -0.009019620716571808,
            0.06558357924222946,
            -0.09508133679628372,
            0.024743659421801567,
            0.0011226491769775748,
            -0.012898767367005348,
            0.059865303337574005,
            -0.05025388300418854,
            -0.049510590732097626,
            -0.008633779361844063,
            0.05323025584220886,
            0.039150793105363846,
            0.013263428583741188,
            0.009545925073325634,
            -0.04491465911269188,
            -0.0886916071176529,
            -0.0076879230327904224,
            -0.006989659275859594,
            -0.07146976888179779,
            0.01650065742433071,
            0.06489456444978714,
            -0.021112024784088135,
            -0.015704989433288574,
            0.09536503255367279,
            -0.03978295251727104,
            -0.012357384897768497,
            -0.07090628892183304,
            -0.02465430088341236,
            -0.00527138402685523,
            -0.019762001931667328,
            0.024407854303717613,
            -0.009316686540842056,
            -0.06012941524386406,
            0.02817600965499878,
            0.06469543278217316,
            0.00998857244849205,
            -0.0208849236369133,
            -0.040550969541072845,
            -0.06858877837657928,
            -0.0323839969933033,
            0.0691947191953659,
            0.033683519810438156,
            -0.028290290385484695,
            0.017357347533106804,
            0.04979664832353592,
            -0.11509190499782562,
            0.05568959191441536,
            0.07517983764410019,
            0.01323005836457014,
            -0.05861904099583626,
            0.11030414700508118,
            -0.05319420248270035,
            -0.05029455944895744,
            -0.09195085614919662,
            0.020989123731851578,
            -0.014657546766102314,
            -0.019727081060409546,
            0.004338651429861784,
            -0.04121158644556999,
            0.0715227872133255,
            -0.012113216333091259,
            0.0315164290368557,
            -0.030081864446401596,
            0.0009791007032617927,
            -0.02599163167178631,
            -0.017422238364815712,
            -0.013104695826768875,
            0.02084900066256523,
            -0.01814243383705616,
            -0.05544324591755867,
            9.294675157925098e-35,
            -0.015780212357640266,
            -0.02960212714970112,
            -0.09250346571207047,
            -0.05251132324337959,
            0.059180308133363724,
            -0.00815860740840435,
            -0.07327435165643692,
            0.007646909914910793,
            -0.012508057057857513,
            0.0033186820801347494,
            0.019097598269581795,
            -0.024517854675650597,
            0.01737435720860958,
            0.02826048992574215,
            0.047416117042303085,
            -0.05220317095518112,
            -0.07057364284992218,
            0.025871317833662033,
            0.015053531154990196,
            0.05335645377635956,
            -0.009489517658948898,
            -0.0032815055456012487,
            -0.11723297089338303,
            -0.10645163059234619,
            0.011983959935605526,
            0.015106664970517159,
            -0.00018111304962076247,
            0.009606186300516129,
            0.060960568487644196,
            -0.011055754497647285,
            0.005358946043998003,
            -0.05497673526406288,
            -0.06119777634739876,
            0.033553775399923325,
            -0.06254582852125168,
            0.03275046870112419,
            -0.022359270602464676,
            0.00657682353630662,
            -0.018880464136600494,
            0.045178186148405075,
            0.08376535028219223,
            -0.0052696396596729755,
            0.0016118614003062248,
            -0.0024438148830085993,
            -0.058964598923921585,
            0.006908152252435684,
            -0.04088861495256424,
            0.16401785612106323,
            0.004545554518699646,
            0.0683075338602066,
            0.007500850595533848,
            -0.0575987808406353,
            0.02031543478369713,
            -0.03391280397772789,
            0.04199356958270073,
            0.06992710381746292,
            0.018231581896543503,
            -0.003672773949801922,
            0.06507442146539688,
            -0.014926940202713013,
            0.02198823355138302,
            0.06878284364938736,
            -0.03219809755682945,
            -0.07698569446802139,
            0.0032536860089749098,
            -0.09132413566112518,
            -0.020512128248810768,
            -0.010443282313644886,
            -0.02066713385283947,
            -0.03248868137598038,
            -0.04854574054479599,
            0.028578530997037888,
            -0.027562566101551056,
            -0.0924537181854248,
            -0.021262599155306816,
            0.021183334290981293,
            0.059649720788002014,
            -0.05410877615213394,
            0.04118097200989723,
            -0.05276639759540558,
            0.05642405524849892,
            0.1071697250008583,
            0.009123389609158039,
            0.027809713035821915,
            0.07298748940229416,
            0.10752183198928833,
            0.005968763027340174,
            0.009202061221003532,
            0.04128378629684448,
            -0.0032899118959903717,
            -0.007931936532258987,
            -0.07090415805578232,
            0.08569645136594772,
            0.024753089994192123,
            -0.08465538173913956,
            -1.2035937579923939e-08,
            -0.06188613921403885,
            -0.0440424345433712,
            -0.07158017158508301,
            0.002964686369523406,
            -0.0028779907152056694,
            0.06980373710393906,
            -0.08080452680587769,
            0.024055855348706245,
            0.015571794472634792,
            0.09947953373193741,
            -0.009714954532682896,
            -0.002969912486150861,
            -0.08521999418735504,
            0.04183289408683777,
            0.01555780228227377,
            -0.0007820953032933176,
            0.03798016533255577,
            0.00773600721731782,
            0.0009412022773176432,
            -0.08869428932666779,
            -0.010179715231060982,
            0.05713403970003128,
            0.009733786806464195,
            0.02397443912923336,
            -0.0023370806593447924,
            0.08744580298662186,
            0.004010671749711037,
            0.02967038005590439,
            0.010210618376731873,
            0.09156322479248047,
            0.002747718244791031,
            0.004813105333596468,
            -0.051329370588064194,
            -0.06491392105817795,
            0.0603092797100544,
            0.058630168437957764,
            0.017056573182344437,
            0.05640222132205963,
            -0.0426688976585865,
            -0.058066874742507935,
            0.0599210262298584,
            -0.04774283245205879,
            0.02936861477792263,
            0.06920412927865982,
            0.017804110422730446,
            0.014914610423147678,
            -0.07119116187095642,
            0.010859792120754719,
            0.027218816801905632,
            -0.09484763443470001,
            -0.12160322815179825,
            -0.034446004778146744,
            0.0802493467926979,
            -0.021988609805703163,
            -0.03363404422998428,
            0.06795895844697952,
            -0.003408966353163123,
            -0.05421500653028488,
            0.033392392098903656,
            -0.03356771171092987,
            0.12905149161815643,
            0.04680142551660538,
            -0.021267320960760117,
            0.16315853595733643
        ]
    ],
    "retrieved_docs": [
        "QABot_Training_Data.pdf",
        "QABot_Training_Data.pdf"
    ],
    "llm_prompt": "Answer the question based on the context provided.\nContext:\nStream Ciphers \u2022 process the message bit by bit (as a stream) \u2022 typically have a (pseudo) random stream key \u2022 combined (XOR) with plaintext bit by bit \u2022 randomness of stream key completely destroys any statistically properties in the message \u2022 Ci = Mi XOR StreamKeyi \u2022 what could be simpler!!!! \u2022 but must never reuse stream key \u2022 otherwise, can remove effect and recover messages, M\u2a01K\u2a01K = M Stream Cipher Properties \u2022 some design considerations are: \u2022 statistically random \u2022 depends on large enough key \u2022 large linear complexity \u2022 correlation immunity \u2022 confusion \u2022 diffusion How to generate Stream Key? \u2022 How to generate Stream Key? Stream Ciphers \u2022 Idea: replace \u201crand\u201d by \u201cpseudo rand\u201d \u2022 Use Pseudo Random Number Generator \u2022 A secure PRNG produces output that looks indistinguishable from random \u2022 An attacker who can\u2019t see the internal PRNG state can\u2019t learn any output \u2022 PRNG: {0,1}s \u00ae {0,1}n \u2022 expand a short (e.g., 128-bit) random seed into a long (typically unbounded) string that \u201clooks random\u201d \u2022 Secret key is the seed \u2022 Basic encryption method: Ekey[M] = M \u00c5 PRNG(key) Stream Ciphers \u2022 Protocol: Alice and Bob both seed a secure PRNG with their symmetric secret key, and then use the output as the key for stream key Alice Bob Seed(k) Seed(k) Generate(n) Generate(n) Plaintext Plaintext Ciphertext \u2295 \u2295 Stream Ciphers: Encrypting Multiple Messages \u2022 How do we encrypt multiple messages without key reuses? Alice Bob Seed(k) Seed(k) Generate(n) Generate(n) Plaintext Plaintext Ciphertext \u2295 \u2295 Stream Ciphers: Encrypting Multiple Messages \u2022 Solution: For each message, seed the PRNG with the key and a random IV, concatenated(\u201c|\u201d). Send the IV with the ciphertext Alice Bob Seed(k | IV) Seed(k | IV) Generate(n) Generate(n) Plaintext Plaintext Ciphertext \u2295 \u2295 IV IV Real-world example: RC4 \u2022 a proprietary cipher designed in 1987 \u2022 Extremely simple but effective! \u2022 Very fast - especially in software \u2022 Easily adapts to any key length, byte-oriented stream cipher \u2022 widely used (web SSL/TLS, wireless WEP, WAP) \u2022 A trade secret by RSA Security \u2022 uses that permutation to scramble input info processed a byte at a time RC4 Stream Cipher K RC4 (K|IV) 011010010111 \u2295 M C key (seed) key stream (pseudo random sequence) message ciphertext RC4 Key Schedule \u2022 starts with an array S of numbers: 0\u2026255 \u2022 use key to well and truly shuffle \u2022 S forms internal state of the cipher \u2022 given a key k of length I bytes Throw away T & K, retain S RSA Signatures \u2022 Sign(d, M): \u2022 Compute H(M)d mod n \u2022 Verify(e, n, M, sig) \u2022 Verify that H(M) \u2261 sige mod n RSA Digital Signature Algo Step1: Generate a hash value, or message digest, mHash from the message M to be signed Step2: Pad mHash with a constant value padding1 and pseudorandom value salt to form M\u2019 Step3: Generate hash value H from M\u2019 Step4: Generate a block DB consisting of a constant value padding 2 and salt Step5: Use the mask generating function MGF, which produces a randomized out-put from input H of the same length as DB Step 6: Create the encoded message (EM) block by padding H with the hexadecimal constant bc and the XOR of DB and output of MGF Step 7: Encrypt EM with RSA using the signer\u2019s private key RSA Signatures: Correctness Theorem: sige \u2261 H(M) mod N Proof: sige = [\ud835\udc3b\ud835\udc40\ud835\udc51 ]\ud835\udc52 \ud835\udc5a\ud835\udc5c\ud835\udc51 \ud835\udc41 = \ud835\udc3b(\ud835\udc40)\"# mod N RSA Signatures: Correctness Theorem: sige \u2261 H(M) mod N Proof: sige = [\ud835\udc3b\ud835\udc40\ud835\udc51 ]\ud835\udc52 \ud835\udc5a\ud835\udc5c\ud835\udc51 \ud835\udc41 = \ud835\udc3b(\ud835\udc40)\"# mod N = \ud835\udc3b(\ud835\udc40)$% & '( mod N = [\ud835\udc3b(\ud835\udc40)%(&)]$- \ud835\udc3b\ud835\udc40 mod N = H(M) mod N RSA Digital Signature: Security \u2022 Necessary hardness assumptions: \u2022 Factoring hardness assumption: Given n large, it is hard to find primes pq = n \u2022 Discrete logarithm hardness assumption: Given n large, hash, and hashd mod n, it is hard to find d \u2022 Salt also adds security \u2022 Even the same message and private key will get different signatures Hybrid Encryption \u2022 Issues with public-key encryption \u2022 Notice: We can only encrypt small messages because of the modulo operator \u2022 Notice: There is a lot of math, and computers are slow at math \u2022 Result: We don\u2019t use asymmetric for large messages \u2022 Hybrid encryption: Encrypt data under a randomly generated key K using symmetric encryption, and encrypt K using asymmetric encryption \u2022 EncAsym(PK, K); EncSym(K, large message) \u2022 Benefit: Now we can encrypt large amounts of data quickly using symmetric encryption, and we still have the security of asymmetric encryption Homework (Textbook) \u2013 no submission \u2022 Review Question: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6 \u2022 Problems: \u2022 prove correctness of RSA digital signature \u2022 3.14 & 3.15 Homework 2 - individual \u2022 For Chapter 3 \u2022 Deadline Friday, Nov. 1 before class \u2022 10% penalty per day for late submission Thank you! Network Security Chapter 4 Key Distribution Symmetric Key Distribution and User Authentication 4.2 Ways to achieve symmetric key distribution \u2022 A key could be selected by A and physically delivered to B \u2022 A third party could select the key and physically deliver it to A and B \u2022 If A and B have previously and recently used a key, one party could transmit the new key to the other, using the old key to encrypt the new key \u2022 If A and B each have an encrypted connection to a third-party C, C could deliver a key on the encrypted links to A and B Terminologies \u2022 Session key \u2022 Permanent key \u2022 key distribution center (KDC) \u2022 third party authority, centralized infrastructure \u2022 give permissions for two parties to communicate Diffie-Hellman Key Exchange Section 3.5 In class quiz on Wednesday \u2022 We will have a short quiz on Wednesday, Oct. 30, in class \u2022 A short quiz will cover the materials taught that day. \u2022 Please be on time for class to avoid missing the quiz questions. Authenticated Encryption: Definition \u2022 Authenticated encryption (AE): A scheme that simultaneously guarantees confidentiality and integrity (and authenticity, depending on your threat model) on a message \u2022 Two ways of achieving authenticated encryption: \u2022 Combine schemes that provide confidentiality with schemes that provide integrity \u2022 Use a scheme that is designed to provide confidentiality and integrity Scratchpad: Let\u2019s design it together \u2022 You can use: \u2022 An encryption scheme: Enc(K, M) and Dec(K, M) \u2022 An unforgeable MAC scheme (e.g. HMAC): MAC(K, M) \u2022 First attempt: Alice sends Enc(K1, M) and MAC(K2, M) \u2022 Integrity? Yes, attacker can\u2019t tamper with the MAC \u2022 Confidentiality? No, the MAC is not secure \u2022 Idea 1: Let\u2019s compute the MAC on the ciphertext instead of the plaintext: Enc(K1, M) and MAC(k2, Enc(K1, M)) \u2022 Integrity? Yes, attacker can\u2019t tamper with the MAC \u2022 Confidentiality? Yes, the MAC might leak info about the ciphertext, but that\u2019s okay \u2022 Idea 2: Let\u2019s encrypt the MAC too: Enc(K1, M || MAC(K2, M)) \u2022 Integrity? Yes, attacker can\u2019t tamper with the MAC \u2022 Confidentiality? Yes, everything is encrypted MAC-then-Encrypt or Encrypt-then-MAC? \u2022 Method 1: Encrypt-then-MAC \u2022 First compute Enc(K1, M) \u2022 Then MAC the ciphertext: MAC(K2, Enc(K1, M)) \u2022 Method 2: MAC-then-encrypt \u2022 First compute MAC(K2, M) \u2022 Then encrypt the message and the MAC together: Enc(k1, M || MAC(K2, M)) \u2022 Which is better? \u2022 In theory, both are secure if applied properly \u2022 MAC-then-encrypt has a flaw: You don\u2019t know if tampering has occurred until after decrypting \u2022 Attacker can supply arbitrary tampered input, and you always have to decrypt it \u2022 Passing attacker-chosen input through the decryption function can cause side-channel leaks \u2022 Always use encrypt-then-MAC because it\u2019s more robust to mistakes TLS 1.0 \u201cLucky 13\u201d Attack \u2022 TLS: A protocol for sending encrypted and authenticated messages over the Internet \u2022 TLS 1.0 uses MAC-then-encrypt: Enc(k1, M || MAC(k2, M)) \u2022 The encryption algorithm is AES-CBC \u2022 The Lucky 13 attack abuses MAC-then-encrypt to read encrypted messages \u2022 Guess a byte of plaintext and change the ciphertext accordingly \u2022 The MAC will error, but the time it takes to error is different depending on if the guess is correct \u2022 Attacker measures how long it takes to error in order to learn information about plaintext \u2022 TLS will send the message again if the MAC errors, so the attacker can guess repeatedly \u2022 Takeaways \u2022 Side channel attack: The algorithm is proved secure, but poor implementation made it vulnerable \u2022 Always encrypt-then-MAC Authenticated Encryption: Summary \u2022 Authenticated encryption: A scheme that simultaneously guarantees confidentiality and integrity (and authenticity) on a message \u2022 First approach: Combine schemes that provide confidentiality with schemes that provide integrity and authenticity \u2022 MAC-then-encrypt: Enc(K1, M || MAC(K2, M)) \u2022 Encrypt-then-MAC: MAC(K2, Enc(K1, M)) \u2022 Always use Encrypt-then-MAC because it's more robust to mistakes Digital Signature Digital Signatures \u2022 NIST FIPS PUB 186-4 - the result of a cryptographic transformation of data that, when properly implemented, provides a mechanism for verifying origin authentication, data integrity, and signatory non- repudiation \u2022 Based on asymmetric keys Digital Signatures \u2022 Asymmetric cryptography is good because we don\u2019t need to share a secret key \u2022 Digital signatures are the asymmetric way of providing integrity/authenticity to data \u2022 Assume that Alice and Bob can communicate public keys without David interfering Digital Signatures: Definition \u2022 Three parts: \u2022 KeyGen() \u2192 PK, SK: Generate a public/private keypair, where PK is the verify (public) key, and SK is the signing (secret) key \u2022 Sign(SK, M) \u2192 sig: Sign the message M using the signing key SK to produce the signature sig \u2022 Verify(PK, M, sig) \u2192 {0, 1}: Verify the signature sig on message M using the verify key PK and output 1 if valid and 0 if invalid \u2022 Properties: \u2022 Correctness: Verification should be successful for a signature generated over any message \u2022 Verify(PK, M, Sign(SK, M)) = 1 for all PK, SK \u2190 KeyGen() and M \u2022 Efficiency: Signing/verifying should be fast \u2022 Security: Same as for MACs except that the attacker also receives PK \u2022 Namely, no attacker can forge a signature for a message RSA Signature \u2022 KeyGen(): \u2022 Randomly pick two large primes, p and q \u2022 Compute n = pq \u2022 n is usually between 2048 bits and 4096 bits long \u2022 Choose e \u2022 Requirement: e is relatively prime to (p - 1)(q - 1) \u2022 Requirement: 2 < e < (p - 1)(q - 1) \u2022 Compute d = e-1 mod (p - 1)(q - 1) \u2022 Public key: n and e \u2022 Private key: d A Short Quiz \u2022 We will have a short quiz on Wednesday, Oct. 30, in class \u2022 A short quiz will cover the materials taught that day. Existentially unforgeable \u2022 A secure MAC is existentially unforgeable: without the key, an attacker cannot create a valid tag on a message \u2022 David cannot generate MAC(K, M') without K \u2022 David cannot find any M' \u2260 M such that MAC(K, M') = MAC(K, M) Example: HMAC \u2022 issued as RFC 2104 [1] \u2022 has been chosen as the mandatory-to-implement MAC for IP Security \u2022 Used in Transport Layer Security (TLS) and Secure Electronic Transaction (SET) [1] \u201cHMAC: Keyed-Hashing for Message Authentication\u201d, RFC 2104, https://datatracker.ietf.org/doc/html/rfc2104 HMAC(K, M) \u2022 will produce two keys to increase security \u2022 If key is longer than the desired size, we can hash it first, but be careful with using keys that are too much smaller, they have to have enough randomness in them \u2022 Output H[(K+ \u2295opad) || H[(K+ \u2295ipad) || M]] Example: HMAC \u2022 HMAC(K, M): \u2022 Output H[(K+ \u2295opad) || H[(K+ \u2295ipad) || M]] \u2022 Use K to derive two different keys \u2022 opad (outer pad) is the hard-coded byte 0x5c repeated until it\u2019s the same length as K+ \u2022 ipad (inner pad) is the hard-coded byte 0x36 repeated until it\u2019s the same length as K+ \u2022 As long as opad and ipad are different, you\u2019ll get two different keys \u2022 For paranoia, the designers chose two very different bit patterns, even though they theoretically need only differ in one bit HMAC A B A \u2a01B 0 0 0 0 1 1 1 0 1 1 1 0 K+ = !H \ud835\udc3e \ud835\udc3e \ud835\udc56\ud835\udc60 \ud835\udc59\ud835\udc4e\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc5f \ud835\udc61\u210e\ud835\udc4e\ud835\udc5b \ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58 \ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52 \ud835\udc3e \ud835\udc5c\ud835\udc61\u210e\ud835\udc52\ud835\udc5f\ud835\udc64\ud835\udc56\ud835\udc60\ud835\udc52 ipad = 00110110 , repeat b/8 times opad = 01011100, repeat b/8 times HMAC procedure \u2022 Step 1: Append zeros to the left end of K to create a b-bit string K+ (e.g., if K is of length 160 bits and b = 512, then K will be appended with 44 zero bytes); \u2022 Step 2: XOR (bitwise exclusive-OR) K+ with ipad to produce the b-bit block Si; \u2022 Step 3: Append M to Si; \u2022 Step 4: Apply H to the stream generated in step 3; \u2022 Step 5: XOR K+ with opad to produce the b-bit block So; \u2022 Step 6: Append the hash result from step 4 to So; \u2022 Step 7: Apply H to the stream generated in step 6 and output the result. HMAC Properties \u2022 HMAC(K, M) = H[(K+ \u2295opad) || H((K+ \u2295ipad) || M]] \u2022 HMAC is a hash function, so it has the properties of the underlying hash too \u2022 It is collision resistant \u2022 Given HMAC(K, M), an attacker can\u2019t learn M \u2013 one way \u2022 If the underlying hash is secure, HMAC doesn\u2019t reveal M, but it is still deterministic \u2022 You can\u2019t verify a tag T if you don\u2019t have K \u2022 This means that an attacker can\u2019t brute-force the message M without knowing K MACs: Summary \u2022 Inputs: a secret key and a message \u2022 Output: a tag on the message \u2022 A secure MAC is unforgeable: Even if David can trick Alice into creating MACs for messages that David chooses, David cannot create a valid MAC on a message that she hasn't seen before \u2022 Example: HMAC(K, M) = H((K+ \u2295opad) || H((K+ \u2295ipad) || M)) \u2022 MACs do not provide confidentiality Do MACs provide integrity? \u2022 Do MACs provide integrity? \u2022 Yes. An attacker cannot tamper with the message without being detected \u2022 Do MACs provide authenticity? \u2022 It depends on your threat model \u2022 If only two people have the secret key, MACs provide authenticity: it has a valid MAC, and it\u2019s not from me, so it must be from the other person \u2022 More than one secret key, If a message has a valid MAC, you can be sure it came from someone with the secret key, but you can\u2019t narrow it down to one person \u2022 Do MACs provide confidentiality? Authenticated Encryption Authenticated Encryption: Definition \u2022 Authenticated encryption (AE): A scheme that simultaneously guarantees confidentiality and integrity (and authenticity, depending on your threat model) on a message \u2022 Two ways of achieving authenticated encryption: \u2022 Combine schemes that provide confidentiality with schemes that provide integrity \u2022 Use a scheme that is designed to provide confidentiality and integrity Length Extension Attacks \u2022 Length extension attack: Given H(x) and the length of x, but not x, an attacker can create H(x || m) for any m of the attacker\u2019s choosing \u2022 Length extension attack - Wikipedia \u2022 SHA-256 (256-bit version of SHA-2) is vulnerable \u2022 SHA-3 is not vulnerable Does hashes provide integrity? \u2022 It depends on your threat model \u2022 Scenario \u2022 Mozilla publishes a new version of Firefox on some download servers \u2022 Alice downloads the program binary \u2022 How can she be sure that nobody tampered with the program? \u2022 Idea: use cryptographic hashes \u2022 Mozilla hashes the program binary and publishes the hash on its website \u2022 Alice hashes the binary she downloaded and checks that it matches the hash on the website \u2022 If Alice downloaded a malicious program, the hash would not match (tampering detected!) \u2022 An attacker can\u2019t create a malicious program with the same hash (collision resistance) \u2022 Threat model: We assume the attacker cannot modify the hash on the website \u2022 We have integrity, as long as we can communicate the hash securely Do hashes provide integrity? \u2022 It depends on your threat model \u2022 Scenario \u2022 Alice and Bob want to communicate over an insecure channel \u2022 David might tamper with messages \u2022 Idea: Use cryptographic hashes \u2022 Alice sends her message with a cryptographic hash over the channel \u2022 Bob receives the message and computes a hash on the message \u2022 Bob checks that the hash he computed matches the hash sent by Alice \u2022 Threat model: David can modify the message and the hash \u2022 No integrity! Man-in-the-middle attack Alice M\u2019 MD\u2019 M MD M MD M\u2019 MD\u2019 Bob David Do hashes provide integrity? \u2022 It depends on your threat model \u2022 If the attacker can modify the hash, hashes don\u2019t provide integrity \u2022 Main issue: Hashes are unkeyed functions \u2022 There is no secret key being used as input, so any attacker can compute a hash on any value Solutions \u2022 A message digest created using a secret symmetric key is known as a Message Authentication Code (MAC), because it can provide assurance that the message has not been modified \u2022 The sender can also generate a message digest and then encrypt the digest using the private key of an asymmetric key pair, forming a digital signature. The signature must then be verified by the receiver through comparing it with a locally generated digest Hashes: Summary \u2022 Map arbitrary-length input to fixed-length output \u2022 Output is deterministic \u2022 Security properties \u2022 One way: Given an output y, it is infeasible to find any input x such that H(x) = y. \u2022 Second preimage resistant: Given an input x, it is infeasible to find another input x' \u2260 x such that H(x) = H(x'). \u2022 Collision resistant: It is infeasible to find any pair of inputs x' \u2260 x such that H(x) = H(x\u2019). \u2022 Randomized output \u2022 Some hashes are vulnerable to length extension attacks \u2022 Hashes don\u2019t provide integrity (unless you can publish the hash securely) Message Authentication Code Message authentication code (MAC) \u2022 generated by an algorithm that creates a small fixed-sized block \u2022 depending on both message and some key \u2022 not be reversible \u2022 MACM = F(KAB, M) \u2022 appended to message as a signature \u2022 receiver performs same computation on message and checks it matches the MAC \u2022 provides assurance that message is unaltered and comes from sender MACs: Usage \u2022 Alice wants to send M to Bob, but doesn\u2019t want David to tamper with it \u2022 Alice sends M and T = MAC(K, M) to Bob \u2022 Bob receives M and T \u2022 Bob computes MAC(K, M) and checks that it matches T \u2022 If the MACs match, Bob is confident the message has not been tampered with (integrity) MACs: Definition \u2022 Two parts: \u2022 KeyGen() \u2192 K: Generate a key K \u2022 MAC(K, M) \u2192 T: Generate a tag T for the message M using key K \u2022 Inputs: A secret key and an arbitrary-length message \u2022 Output: A fixed-length tag on the message \u2022 Properties \u2022 Correctness: Determinism \u2022 Note: Some more complicated MAC schemes have an additional Verify(K, M, T) function that don\u2019t require determinism, but this is out of scope \u2022 Efficiency: Computing a MAC should be efficient \u2022 Security: existentially unforgeable under chosen plaintext attack Mid-term Exam \u2022 Nov. 6, 2024 (Wednesday), 12:00 pm \u2013 12:50 pm, in class \u2022 Closed book, but you're allowed to bring one cheat sheet (1 A4-sized paper) \u2022 Chapter 1 \u2013 3 \u2022 Will have a review class on Nov. 1st , during class Message Authentication Message authentication \u2022 message authentication is concerned with: \u2022 protecting the integrity of a message \u2022 validating identity of originator \u2022 non-repudiation of origin (dispute resolution) \u2022 then three alternative functions used: \u2022 message encryption \u2013 symmetric \u2022 message authentication code (MAC) \u2022 digital signature Message encryption \u2022 Symmetric message encryption by itself also provides a measure of authentication \u2022 if symmetric encryption is used then: \u2022 receiver knows sender must have created it \u2022 since only sender and receiver know key used \u2022 know content cannot be altered Homework 1 questions \u2022 Symmetric Block Cypher provides authentication and confidentiality \u2022 Ans: True Message encryption \u2022 if public-key encryption is used: \u2022 encryption provides no confidence of sender \u2022 since anyone potentially knows public-key \u2022 so, need to recognize corrupted messages \u2022 however, if \u2022 sender signs message using their private-key \u2022 then encrypts with recipients\u2019 public key \u2022 have both secrecy and authentication \u2022 but at cost of two public-key uses on message Reasons to avoid encryption authentication \u2022 Encryption software is quite slow \u2022 Encryption hardware costs are nonnegligible \u2022 Encryption hardware is optimized toward large data sizes \u2022 An encryption algorithm may be protected by a patent Hash Function Hash functions \u2022 Hash function: h = H(M) \u2022 M can be of any size \u2022 h is always of fixed size \u2022 Typically, h << size(M) One use case - using hash function \u2022 Initialization: A and B share a common secret, SAB \u2022 Message, M \u2022 A calculates MDM = H (SAB || M) \u2022 B recalculates MD\u2019M, and check \u2022 MD\u2019M = MDM Requirements for secure hash functions \u2022 1. can be applied to any sized message M \u2022 2. produces fixed-length output h \u2022 3. is easy to compute h=H(M) for any message M \u2022 4. given h is infeasible to find x s.t. H(x)=h \u2022 one-way property or preimage resistance \u2022 5. given x is infeasible to find x\u2019 s.t. H(x\u2019)=H(x) \u2022 weak collision resistance or second pre-image resistant \u2022 6. infeasible to find any pair of x,x\u2019 s.t. H(x\u2019)=H(x) \u2022 strong collision resistance Hash Function: Collision Resistance \u2022 Collision: Two different inputs with the same output \u2022 x \u2260 x' and H(x) = H(x') \u2022 Can we design a hash function with no collisions? \u2022 No, because there are more inputs than outputs (pigeonhole principle) \u2022 However, we want to make finding collisions infeasible for an attacker \u2022 Collision resistance: It is infeasible to (i.e. no polynomial time attacker can) find any pair of inputs x' \u2260 x such that H(x) = H(x') Secure hash function \u2022 A hash function that satisfies the first five properties is referred to as a weak hash function \u2022 Security: random/unpredictability, no predictable patterns for how changing the input affects the output \u2022 Changing 1 bit in the input causes the output to be completely different \u2022 Also called \u201crandom oracle\u201d assumption Secure hash function \u2022 A hash function that satisfies the first five properties is referred to as a weak hash function \u2022 Security: random/unpredictability, no predictable patterns for how changing the input affects the output \u2022 Changing 1 bit in the input causes the output to be completely different \u2022 Also called \u201crandom oracle\u201d assumption \u2022 A message digest \u2022 a cryptographic hash function containing a string of digits created by a one- way hashing formula \u2022 provides data integrity \u2022 Examples: SHA-1 (Secure Hash Algorithm 1), SHA-2, SHA-3, MD5 Hash Function: Examples \u2022 MD5 \u2022 Output: 128 bits \u2022 Security: Completely broken \u2022 SHA-1 \u2022 Output: 160 bits \u2022 Security: Completely broken in 2017 \u2022 Was known to be weak before 2017, but still used sometimes \u2022 SHA-2 \u2022 Output: 256, 384, or 512 bits (sometimes labeled SHA-256, SHA-384, SHA-512) \u2022 Not currently broken, but some variants are vulnerable to a length extension attack \u2022 Current standard \u2022 SHA-3 (Keccak) \u2022 Output: 256, 384, or 512 bits \u2022 Current standard (not meant to replace SHA-2, just a different construction) Length Extension Attacks \u2022 Length extension attack: Given H(x) and the length of x, but not x, an attacker can create H(x || m) for any m of the attacker\u2019s choosing \u2022 Length extension attack - Wikipedia \u2022 SHA-256 (256-bit version of SHA-2) is vulnerable \u2022 SHA-3 is not vulnerable Attack approaches \u2022 Mathematical attacks: several approaches, all equivalent in effort to factoring the product of two primes. The defense against mathematical attacks is to use a large key size. \u2022 Timing attacks: These depend on the running time of the decryption algorithm \u2022 Chosen ciphertext attacks: this type of attacks exploits properties of the RSA algorithm by selecting blocks of data. These attacks can be thwarted by suitable padding of the plaintext, such as PKCS1 V1.5 in SSL A simple attack on textbook RSA \u2022 Session-key K is 64 bits. View K \u00ce {0,\u2026,264} \u2022 Eavesdropper sees: C = Ke (mod N) . \u2022 Suppose K = K1\u00d7K2 where K1, K2 < 234 . \u2022 Then: C/K1 e = K2 e (mod N) \u2022 Build table: C/1e, C/2e, C/3e, \u2026, C/234e . time: 234 For K2 = 0,\u2026, 234 test if K2 e is in table. time: 234\u00d734 \u2022 Attack time: \u00bb240 << 264 Web Browser Web Server Random session key K d Client Hello Server Hello (e, N) C = RSA (K) Take-home exercise \u2013 no need to submit \u2022 SW textbook (6th edition) problems: 3.14 & 3.15 Homomorphic encryption \u2022 Encryption scheme that allows computation on ciphertexts \u2022 an extension of public-key encryption scheme that allows anyone in possession of the public key to perform operations on encrypted data without access to the decryption key \u2022 Partially Homomorphic Encryption: Initial public-key systems that allow this for either addition or multiplication, but not both. \u2022 i.e. RSA \u2022 Fully homomorphic encryption (FHE) Application of homomorphic encryption \u2022 One Use case: cloud computing \u2022 A weak computational device Alice (e.g., a mobile phone or a laptop) wishes to perform a computationally heavy task, beyond her computational means. She can delegate it to a much stronger (but still feasible) machine Bob (the cloud, or a supercomputer) who offers the service of doing so. The problem is that Alice does not trust Bob, who may give the wrong answer due to laziness, fault, or malice. E (Pk, data) E (Pk, f(data)) RSA reading materials \u2022 A Method for Obtaining Digital Signatures and Public-Key Cryptosystems RSA example 1. Select primes: p=17 & q=11 2. Compute n = pq =17\u00d711=187 3. Compute \u00f8(n)=(p\u20131)(q-1)=16\u00d710=160 4. Select e : gcd(e,160)=1; choose e=7 5. Determine d: de=1 mod 160 and d < 160 Value is d=23 since 23\u00d77=161= 10\u00d7160+1 6. Publish public key pk={7,187} 7. Keep secret private key sk={23,17,11} RSA use \u2022 to encrypt a message M the sender: \u2022 obtains public key of recipient pk={e,n} \u2022 computes: C=Me mod n, where 0\u2264M<n \u2022 to decrypt the ciphertext C the owner: \u2022 uses their private key sk={d,p,q} \u2022 computes: M=Cd mod n \u2022 note that the message M must be smaller than the modulus n (block if needed) Plaintext Ciphertext C = \ud835\udc40! pk={e,n} sk={d,p,q} RSA example continue \u2022 sample RSA encryption/decryption is: \u2022 given message M = 88 ( 88<187) \u2022 encryption: C = 887 mod 187 = 11 \u2022 decryption: M = 1123 mod 187 = 88 Example of RSA algorithm RSA key generation \u2022 users of RSA must: \u2022 determine two primes at random - p, q \u2022 select either e or d and compute the other \u2022 primes p,q must not be easily derived from modulus n=p.q \u2022 means must be sufficiently large \u2022 typically guess and use probabilistic test \u2022 exponents e, d are inverses, so use Inverse algorithm to compute the other Correctness of RSA \u2022 Euler\u2019s theorem: if gcd (M, n) = 1, then \ud835\udc40!(#) = 1 mod n. Here \u03c6(n) is Euler\u2019s totient function: the number of integers in {1, 2, . . ., n-1} which are relatively prime to n. When n is a prime, this theorem is just Fermat\u2019s little theorem M\u2019 = \ud835\udc36% mod n = \ud835\udc40&% mod n = \ud835\udc40(! # )* mod n = [\ud835\udc40!(#)](, \ud835\udc40 mod n = M mod n Attack approaches \u2022 Mathematical attacks: several approaches, all equivalent in effort to factoring the product of two primes. The defense against mathematical attacks is to use a large key size. \u2022 Timing attacks: These depend on the running time of the decryption algorithm \u2022 Chosen ciphertext attacks: this type of attacks exploits properties of the RSA algorithm by selecting blocks of data. These attacks can be thwarted by suitable padding of the plaintext, such as PKCS1 V1.5 in SSL A simple attack on textbook RSA \u2022 Session-key K is 64 bits. View K \u00ce {0,\u2026,264} \u2022 Eavesdropper sees: C = Ke (mod N) . \u2022 Suppose K = K1\u00d7K2 where K1, K2 < 234 . \u2022 Then: C/K1 e = K2 e (mod N) \u2022 Build table: C/1e, C/2e, C/3e, \u2026, C/234e . time: 234 For K2 = 0,\u2026, 234 test if K2 e is in table. time: 234\u00d734 \u2022 Attack time: \u00bb240 << 264 Web Browser Web Server Random session key K d Client Hello Server Hello (e, N) C = RSA (K) Public-Key Cryptography Algorithm (RSA) RSA Public-key encryption \u2022 by Rivest, Shamir & Adleman of MIT in 1977 \u2022 currently the \u201cwork horse\u201d of Internet security \u2022 most public key infrastructure (PKI) products \u2022 SSL/TLS: certificates and key-exchange \u2022 secure e-mail: PGP, Outlook, \u2026. \u2022 based on exponentiation in a finite (Galois) field over integers modulo a prime \u2022 exponentiation takes O((log n)3) operations (easy) \u2022 security due to cost of factoring large integer numbers \u2022 factorization takes O(e log n log log n) operations (hard) \u2022 uses large integers (eg. 1024 bits) RSA key setup \u2022 each user generates a public/private key pair by: \u2022 selecting two large primes at random - p, q \u2022 computing their system modulus n=p!q \u2022 note \u00f8(n)=(p-1)(q-1) \u2022 selecting at random the encryption key e \u2022 where 1<e<\u00f8(n), gcd(e,\u00f8(n))=1 \u2022 solve following equation to find decryption key d \u2022 ed=1 mod \u00f8(n) \u2022 publish their public encryption key: pk={e,n} \u2022 keep secret private decryption key: sk={d,p,q} RSA example 1. Select primes: p=17 & q=11 2. Compute n = pq =17\u00d711=187 3. Compute \u00f8(n)=(p\u20131)(q-1)=16\u00d710=160 4. Select e : gcd(e,160)=1; choose e=7 5. Determine d: de=1 mod 160 and d < 160 Value is d=23 since 23\u00d77=161= 10\u00d7160+1 6. Publish public key pk={7,187} 7. Keep secret private key sk={23,17,11} Encryption steps \u2022 step1: generate a pair of keys \u2022 step2: keep the private key / secret key (SK) and distribute the public key (PK) \u2013 place PK in a public register or other accessible file \u2022 step3: Bob encrypts the message with Alice\u2019s PK \u2022 step4: upon receiving the ciphertext (CT), Alice decrypt CT with SK Public-Key Encryption: Definition \u2022 Three parts: \u2022 KeyGen() \u2192 PK, SK: Generate a public/private keypair, where PK is the public key, and SK is the private (secret) key \u2022 Enc(PK, M) \u2192 C: Encrypt a plaintext M using public key PK to produce ciphertext C \u2022 Dec(SK, C) \u2192 M: Decrypt a ciphertext C using secret key SK \u2022 Properties \u2022 Correctness: Decrypting a ciphertext should result in the message that was originally encrypted \u2022 Dec(SK, Enc(PK, M)) = M for all PK, SK \u2190 KeyGen() and M \u2022 Efficiency: Encryption/decryption should be fast \u2022 Security: 1. Alice (the challenger) just gives Eve (the adversary) the public key, and Eve doesn\u2019t request encryptions. Eve cannot guess out anything; 2. computationally infeasible to recover M with PK and ciphertext Public-Key Cryptography - Signature Review Private Key Public Key Signature Encryption Public-Key application \u2022 can classify uses into 3 categories: \u2022 encryption/decryption (provide secrecy) \u2022 digital signatures (provide authentication) \u2022 key exchange (of session keys) \u2022 some algorithms are suitable for all uses; others are specific to one \u2022 Either of the two related keys can be used for encryption, with the other used for decryption Security of Public Key Schemes \u2022 Keys used are very large (>512bits) \u2022 like private key schemes brute force exhaustive search attack is always theoretically possible \u2022 Security relies on a large enough difference in difficulty between easy (en/decrypt) and hard (cryptanalyze) problems \u2022 more generally the hard problem is known, it\u2019s just made too hard to do in practice \u2022 Requires the use of very large numbers, hence is slow compared to private/symmetric key schemes Public-Key Cryptography \u2022 In public-key schemes, each person has two keys \u2022 Public key: Known to everybody \u2022 Private key: Only known by that person \u2022 Keys come in pairs: every public key corresponds to one private key \u2022 Uses number theory \u2022 Examples: Modular arithmetic, factoring, discrete logarithm problem, Elliptic logs over Elliptic Curves \u2022 Contrast with symmetric-key cryptography (uses XORs and bit-shifts) \u2022 Messages are numbers \u2022 Contrast with symmetric-key cryptography (messages are bit strings) Public-key Cryptography \u2022 Benefit: \u2022 Drawback: \u2022 Benefit: No longer need to assume that Alice and Bob already share a secret \u2022 Drawback: Much slower than symmetric-key cryptography \u2022 Number theory calculations are much slower than XORs and bit-shifts Reading materials \u2022 Encryption: Strengths and Weaknesses of Public-key Cryptography \u2022 Public-key cryptography is a public invention due to Whitfield Diffie & Martin Hellman at Stanford Uni in 1976 Public-key cryptography \u2022 public-key/two-key/asymmetric cryptography involves the use of two keys: \u2022 a public-key, which may be known by anybody, and can be used to encrypt messages, and verify signatures \u2022 a private-key, known only to the recipient, used to decrypt messages, and sign (create) signatures \u2022 is asymmetric because \u2022 Not the same key \u2022 those who encrypt messages or verify signatures cannot decrypt messages or create signatures Public-Key Encryption \u2022 Everybody can encrypt with the public key \u2022 Only the recipient can decrypt with the private key Public-Key Cryptography - Encryption Encryption steps \u2022 step1: generate a pair of keys \u2022 step2: keep the private key / secret key (SK) and distribute the public key (PK) \u2013 place PK in a public register or other accessible file \u2022 step3: Bob encrypts the message with Alice\u2019s PK \u2022 step4: upon receiving the ciphertext (CT), Alice decrypt CT with SK An example of key distribution SSH key-based client authentication. Source: Peiyue and Yuanyuan 2021. 1.Peiyue, G. and F. Yuanyuan. 2021. \"What Is SSH?\" Info-Finder, Huawei, July 22. Updated 2021-12-14. Accessed 2023-04-18. RC4 Stream Cipher K RC4 (K|IV) 011010010111 \u2295 M C key (seed) key stream (pseudo random sequence) message ciphertext RC4 Key Schedule \u2022 starts with an array S of numbers: 0\u2026255 \u2022 use key to well and truly shuffle \u2022 S forms internal state of the cipher \u2022 given a key k of length I bytes Throw away T & K, retain S RC4 Encryption \u2022 encryption continues shuffling array values \u2022 sum of shuffled pair selects \"stream key\" value \u2022 XOR with next byte of message to en/decrypt RC4 RC4 Security \u2022 claimed secure against known attacks \u2022 since RC4 is a stream cipher, must never reuse a key \u2022 have a concern with WEP, but due to key handling rather than RC4 itself \u2022 RC4 Biases: It is extensively studied, not a completely secure PRNG, first part of output biased, when used as stream cipher, should use RC4-Drop[n] \u2022 Which drops first n bytes before using the output \u2022 Conservatively, set n=3072 Summary \u2013 Chapter 2 \u2022 Symmetric block cipher \u2022 DES, 3DES \u2022 AES \u2022 Random number \u2022 true random number \u2022 pseudorandom number \u2022 Stream cipher \u2022 The security of symmetric encryption depends on the secrecy of the key \u2022 Symmetric encryption: pros and cons Modular Arithmetic \u2022 Definition (congruent modulo): \u2022 given b \u2013 a = km for some k \ud835\udf16\ud835\udc4d, then a \u2261\ud835\udc4f(mod m) \u2022 Given a \u2261\ud835\udc4f(mod m) and c \u2261\ud835\udc51(mod m), then \u2022 a + b \u2261c + d (mod m) \u2022 a - b \u2261c - d (mod m) \u2022 a + c \u2261b + d (mod m) \u2022 a \u00d7 c \u2261b \u00d7 d (mod m) \u2022 ak \u2261bk (mod m) \u2022 ka = kb (mod m) \u2022 p(a) \u2261p(b) (mod m), any polynomial p(x) with integer coefficients \u2022 A \u2a01\ud835\udc35\u2a01\ud835\udc35= A Thank you! Network Security Chapter 3 Public-Key Cryptography and Message Authentication Public-Key Cryptography Conventional cryptography \u2022 traditional private/secret/single-key cryptography uses one key \u2022 shared by both sender and receiver \u2022 if this key is disclosed, communications are compromised \u2022 also is symmetric, parties are equal Pros and cons \u2022 Pros: \u2022 Encryption is fast for large amounts of data \u2022 Provide the same level of security with a shorter encryption key \u2022 By now, it\u2019s unbreakable to quantum computing \u2022 Cons \u2022 Key distribution assumes a secure channel \u2022 Does not protect sender from receiver forging a message & claiming it\u2019s sent by sender \u2022 It does not scale well for large networks. It requires a separate key for each pair of communicating parties, which can result in a large number of keys to manage and protect. Homework 1 - individual \u2022 Chapter 1 & 2 \u2022 Deadline: Tuesday, October 8, 11:59 PM \u2022 Submit your homework via the provided link. \u2022 The Google submission timestamp will be considered final. \u2022 A 10% penalty will be applied for each day of late submission. Review & Quiz I \u2022 Chapter 1 & 2 \u2022 Wednesday (Oct. 9, 2024), in class \u2022 Please ensure your participation \u2022 No make-up quiz Pseudorandom Number Generators (PRNGs) \u2022 True randomness is expensive \u2022 Pseudorandom number generator (PRNGs): An algorithm that uses a little bit of true randomness to generate a lot of random-looking output \u2022 Also called deterministic random bit generators (DRBGs) \u2022 PRNGs are deterministic: Output is generated according to a set algorithm \u2022 However, for an attacker who can\u2019t see the internal state, the output is computationally indistinguishable from true randomness PRNG: Definition \u2022 A PRNG has two functions: \u2022 PRNG.Seed(randomness): Initializes the internal state using the entropy \u2022 Input: Some truly random bits \u2022 PRNG.Generate(n): Generate n pseudorandom bits \u2022 Input: A number n \u2022 Output: n pseudorandom bits \u2022 Updates the internal state as needed \u2022 Properties \u2022 Correctness: Deterministic \u2022 Efficiency: Efficient to generate pseudorandom bits \u2022 Security: Indistinguishability from random \u2022 Rollback resistance: cannot deduce anything about any previously-generated bit Example construction of PRNG \u2022 Using block cipher in Counter (CTR) mode: \u2022 If you want m random bits, and a block cipher with Ek has n bits, apply the block cipher m/n times and concatenate the result: \u2022 PRNG.Seed(K | IV) = Ek(IV, 1) | Ek(IV, 2) | Ek(IV, 3) \u2026 Ek(IV, ceil(m/n)), \u2022 | is concatenation \u2022 Initialization vector (IV) / Nonce \u2013 typically is random or pseudorandom Randomness, PRNG output PRNG: Security \u2022 Can we design a PRNG that is truly random? \u2022 A PRNG cannot be truly random \u2022 The output is deterministic given the initial seed \u2022 A secure PRNG is computationally indistinguishable from random to an attacker \u2022 Game: Present an attacker with a truly random sequence and a sequence outputted from a secure PRNG \u2022 An attacker should be able to determine which is which with probability \u22480 \u2022 Equivalence: An attacker cannot predict future output of the PRNG Create pseudorandom numbers \u2022 Truly random numbers are impossible with any program! \u2022 However, we can generate seemingly random numbers, called pseudorandom numbers \u2022 The function rand() returns a non-negative number between 0 and RAND_MAX \u2022 For C, it is defined in stdlib.h \u2022 arc4random() is a function available in some operating systems (primarily BSD-based systems like macOS and FreeBSD) that generates random numbers. It is part of the C standard library and provides a more secure and higher-quality source of random numbers compared to rand() PRNGs: Summary \u2022 True randomness requires sampling a physical process \u2022 PRNG: An algorithm that uses a little bit of true randomness to generate a lot of random-looking output \u2022 Seed(entropy): Initialize internal state \u2022 Generate(n): Generate n bits of pseudorandom output \u2022 Security: computationally indistinguishable from truly random bits Stream Ciphers Stream Ciphers \u2022 process the message bit by bit (as a stream) \u2022 typically have a (pseudo) random stream key \u2022 combined (XOR) with plaintext bit by bit \u2022 randomness of stream key completely destroys any statistically properties in the message \u2022 Ci = Mi XOR StreamKeyi \u2022 what could be simpler!!!! \u2022 but must never reuse stream key \u2022 otherwise, can remove effect and recover messages, M\u2a01K\u2a01K = M Properties of Random Numbers \u2022 Randomness \u2022 Uniformity \u2022 distribution of bits in the sequence should be uniform \u2022 Independence \u2022 no one subsequence in the sequence can be inferred from the others \u2022 Unpredictable \u2022 satisfies the \"next-bit test\u201c Entropy \u2022 A measure of uncertainty \u2022 In other words, a measure of how unpredictable the outcomes are \u2022 High entropy = unpredictable outcomes = desirable in cryptography \u2022 The uniform distribution has the highest entropy (every outcome equally likely, e.g. fair coin toss) \u2022 Usually measured in bits (so 3 bits of entropy = uniform, random distribution over 8 values) Entropy of an information source True random numbers generators \u2022 Several sources of randomness \u2013 natural sources of randomness \u2022 decay times of radioactive materials \u2022 electrical noise from a resistor or semiconductor \u2022 radio channel or audible noise \u2022 keyboard timings \u2022 disk electrical activity \u2022 mouse movements \u2022 Physical unclonable function (PUF) \u2022 Some are better than others Combining sources of randomness \u2022 Suppose r1, r2, \u2026, rk are random numbers from different sources. E.g., r1 = electrical noise from a resistor or semiconductor r2 = sample of hip-hop music on radio r3 = clock on computer b = r1\u2295r2\u2295\u2026\u2295rk If any one of r1, r2, \u2026, rk is truly random, then so is b Many poor sources + 1 good source = good entropy Pseudorandom Number Generators (PRNGs) \u2022 True randomness is expensive \u2022 Pseudorandom number generator (PRNGs): An algorithm that uses a little bit of true randomness to generate a lot of random-looking output \u2022 Also called deterministic random bit generators (DRBGs) \u2022 PRNGs are deterministic: Output is generated according to a set algorithm \u2022 However, for an attacker who can\u2019t see the internal state, the output is computationally indistinguishable from true randomness Random and Pseudorandom Numbers When to use random numbers? \u2022 Generation of a stream key for symmetric stream cipher \u2022 Generation of keys for public-key algorithms \u2022 RSA public-key encryption algorithm (described in Chapter 3) \u2022 Generation of a symmetric key for use as a temporary session key \u2022 used in a number of networking applications, such as Transport Layer Security (Chapter 5), Wi-Fi (Chapter 6), e-mail security (Chapter 7), and IP security (Chapter 8) \u2022 In a number of key distribution scenarios \u2022 Kerberos (Chapter 4) Two types of random numbers \u2022 True random numbers: \u2022 generated in non-deterministic ways. They are not predictable and repeatable \u2022 Pseudorandom numbers: \u2022 appear random, but are obtained in a deterministic, repeatable, and predictable manner Properties of Random Numbers \u2022 Randomness \u2022 Uniformity \u2022 distribution of bits in the sequence should be uniform \u2022 Independence \u2022 no one subsequence in the sequence can be inferred from the others \u2022 Unpredictable \u2022 satisfies the \"next-bit test\u201c Entropy \u2022 A measure of uncertainty \u2022 In other words, a measure of how unpredictable the outcomes are \u2022 High entropy = unpredictable outcomes = desirable in cryptography \u2022 The uniform distribution has the highest entropy (every outcome equally likely, e.g. fair coin toss) \u2022 Usually measured in bits (so 3 bits of entropy = uniform, random distribution over 8 values) Entropy of an information source AES Specification \u2022 symmetric block cipher \u2022 128-bit data, 128/192/256-bit keys \u2022 stronger & faster than Triple-DES \u2022 provide full specification & design details \u2022 both C & Java implementations \u2022 NIST have released all submissions & unclassified analyses https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards- and-Guidelines/documents/aes-development/Rijndael-ammended.pdf The AES Cipher - Rijndael \u2022 an iterative rather than feistel cipher \u2022 treats data in 4 groups of 4 bytes \u2022 operates an entire block in every round \u2022 designed to be: \u2022 resistant against known-plaintext attacks \u2022 speed and code compactness on many CPUs \u2022 design simplicity Rijndael \u2022 processes data as 4 groups of 4 bytes (state) = 128 bits \u2022 has 10/12/14 rounds in which state undergoes: \u2022 byte substitution (1 S-box used on every byte) \u2022 shift rows (permute bytes row by row) \u2022 mix columns (alter each byte in a column as a function of all of the bytes in the column) \u2022 add round key (XOR state with key material) \u2022 128-bit keys \u2013 10 rounds, 192-bit keys \u2013 12 rounds, 256-bit keys \u2013 14 rounds AES Encryption and Decryption AES encryption round AES pros \u2022 Most operations can be combined into XOR and table lookups - hence very fast & efficient Take-home Exercises \u2022 Find an AES API to encrypt a text (A), then decrypt it and check whether the original text (A) equals the decrypted text (B). Whether A = B? \u2022 Compare the decryption time with different key lengths, and with DES and 3DES. \u2022 Suggestions: find a large A file. Run decryption a couple of times and take the average. Reading materials \u2022 FIPS 197, Advanced Encryption Standard (AES) (nist.gov) WPEC 2024: NIST Workshop on Privacy- Enhancing Cryptography \u2022 Time: September 24\u201326, 2024 \u2022 Free to register \u2022 Virtual conference via Zoom \u2022 https://csrc.nist.gov/events/2024/wpec2024 Feistel Encryption and Decryption DES encryption \u2022 64 bits plaintext \u2022 56 bits effective key length DES Weakness \u2022 short length key (56 bits) is not secure enough. Brutal force search takes short time. Triple DES (3DES) Decrypting with the wrong key will further convolute the output 3DES \u2022 Triple DES with three different keys \u2013 brute-force complexity 2168 \u2022 3DES is the FIPS-approved symmetric encryption algorithm \u2022 Weakness: slow speed for encryption FIPS \u2013 Federal Information Processing Standards. The United States' Federal Information Processing Standards are publicly announced standards developed by the National Institute of Standards and Technology for use in computer systems by non-military American government agencies and government contractors AES \u2022 clearly a replacement for DES was needed \u2022 have theoretical attacks that can break it \u2022 have demonstrated exhaustive key search attacks \u2022 can use Triple-DES \u2013 but slow with small blocks \u2022 US NIST issued call for ciphers in 1997 \u2022 15 candidates accepted in Jun 98 \u2022 5 were short-listed in Aug-99 \u2022 Rijndael was selected as the AES in Oct-2000 \u2022 issued as FIPS PUB 197 standard in Nov-2001 Criteria to evaluate AES \u2022 General security \u2022 Software implementations \u2022 Restricted-space environments \u2022 Hardware implementations \u2022 Attacks on implementations \u2022 Encryption versus decryption \u2022 Key agility \u2022 Other versatility and flexibility \u2022 Potential for instruction-level parallelism Cryptographic Standards and Guidelines | CSRC (nist.gov) AES Specification \u2022 symmetric block cipher \u2022 128-bit data, 128/192/256-bit keys \u2022 stronger & faster than Triple-DES \u2022 provide full specification & design details \u2022 both C & Java implementations \u2022 NIST have released all submissions & unclassified analyses https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards- and-Guidelines/documents/aes-development/Rijndael-ammended.pdf The AES Cipher - Rijndael \u2022 an iterative rather than feistel cipher \u2022 treats data in 4 groups of 4 bytes \u2022 operates an entire block in every round \u2022 designed to be: \u2022 resistant against known-plaintext attacks \u2022 speed and code compactness on many CPUs \u2022 design simplicity Rijndael \u2022 processes data as 4 groups of 4 bytes (state) = 128 bits \u2022 has 10/12/14 rounds in which state undergoes: \u2022 byte substitution (1 S-box used on every byte) \u2022 shift rows (permute bytes row by row) \u2022 mix columns (alter each byte in a column as a function of all of the bytes in the column) \u2022 add round key (XOR state with key material) \u2022 128-bit keys \u2013 10 rounds, 192-bit keys \u2013 12 rounds, 256-bit keys \u2013 14 rounds Symmetric Block Encryption Block cipher \u2022 the most commonly used symmetric encryption algorithms \u2022 input: fixed-size blocks (Typically 64, 128 bit blocks), output: equal size blocks \u2022 provide secrecy and/or authentication services \u2022 Data Encryption Standard (DES), triple DES (3DES), and the Advanced Encryption Standard (AES)s \u2022 Usually employ Feistel structure Feistel Cipher Structure Feistel Cipher Structure \u2022 most symmetric block ciphers are based on a Feistel Cipher Structure \u2022 based on the two primitive cryptographic operations \u2022 substitution (S-box) \u2022 permutation (P-box) \u2022 provide confusion and diffusion of message Feistel Cipher Structure \u2022 Horst Feistel devised the feistel cipher in the 1973 \u2022 based on concept of invertible product cipher \u2022 partitions input block into two halves \u2022 process through multiple rounds which \u2022 perform a substitution on left data half \u2022 based on round function of right half & subkey \u2022 then have permutation swapping halves \u2022 implements Shannon\u2019s substitution-permutation network concept Feistel Encryption and Decryption A strong encryption algorithm attacker encryption algorithm plaintext / enquiry cyphertext / response Secure Encryption Scheme \u2022 Unconditional security \u2022 no matter how much computer power is available, the cipher cannot be broken since the ciphertext provides insufficient information to uniquely determine the corresponding plaintext \u2022 Computational security \u2022 the cost of breaking the cipher exceeds the value of the encrypted information; \u2022 or the time required to break the cipher exceeds the useful lifetime of the information Desired characteristics \u2022 Cipher needs to completely obscure statistical properties of original message \u2022 more practically Shannon suggested combining elements to obtain: \u2022 Confusion \u2013 how does changing a bit of the key affect the ciphertext? \u2022 Diffusion \u2013 how does changing one bit of the plaintext affect the ciphertext? confusion ciphertext plaintext diffusion Ways to achieve \u2022 Symmetric Encryption: \u2022 substitution / transposition / hybrid \u2022 Asymmetric Encryption: \u2022 Mathematical hardness - problems that are efficient to compute in one direction, but inefficient to reverse by the attacker \u2022 Examples: Modular arithmetic, factoring, discrete logarithm problem, Elliptic Logs over Elliptic Curves Two basic types \u2022 Block Ciphers \u2022 Typically 64, 128 bit blocks \u2022 A k-bit plaintext block maps to a k-bit ciphertext block \u2022 Usually employ Feistel structure \u2022 Stream Ciphers \u2022 A key is used to generate a stream of pseudo-random bits \u2013 key stream \u2022 Just XOR plaintext bits with the key stream for encryption \u2022 For decryption generate the key stream and XOR with the ciphertext! Symmetric Block Encryption Block cipher \u2022 the most commonly used symmetric encryption algorithms \u2022 input: fixed-size blocks (Typically 64, 128 bit blocks), output: equal size blocks \u2022 provide secrecy and/or authentication services \u2022 Data Encryption Standard (DES), triple DES (3DES), and the Advanced Encryption Standard (AES)s \u2022 Usually employ Feistel structure Feistel Cipher Structure Feistel Cipher Structure \u2022 most symmetric block ciphers are based on a Feistel Cipher Structure \u2022 based on the two primitive cryptographic operations \u2022 substitution (S-box) \u2022 permutation (P-box) \u2022 provide confusion and diffusion of message Feistel Cipher Structure \u2022 Horst Feistel devised the feistel cipher in the 1973 \u2022 based on concept of invertible product cipher \u2022 partitions input block into two halves \u2022 process through multiple rounds which \u2022 perform a substitution on left data half \u2022 based on round function of right half & subkey \u2022 then have permutation swapping halves \u2022 implements Shannon\u2019s substitution-permutation network concept Feistel Encryption and Decryption Symmetric Encryption and Message Confidentiality Chapter 2 Model for network security Model for network security \u2022 Using this model requires us to: \u2022 design a suitable algorithm for the security transformation \u2022 generate the secret information (keys) used by the algorithm \u2022 develop methods to distribute and share the secret information \u2022 specify a protocol enabling the principals to use the transformation and secret information for a security service Symmetric Encryption Principles Symmetric encryption \u2022 Sender and recipient share a common/same key \u2022 Was the only type of cryptography, prior to invention of public-key in 1970\u2019s Simplified model of symmetric encryption Symmetric encryption \u2022 Has five ingredients \u2022 Plaintext: the original message or data \u2022 Encryption algorithm: performs various substitutions and transformations on the plaintext \u2022 Secret key \u2022 Ciphertext: the coded message \u2022 Decryption algorithm: takes the ciphertext and the same secret key and produces the original plaintext Other basic terminology \u2022 cipher - algorithm for transforming plaintext to ciphertext \u2022 encipher (encrypt) - converting plaintext to ciphertext \u2022 decipher (decrypt) - recovering plaintext from ciphertext \u2022 cryptography - study of encryption principles/methods \u2022 cryptanalysis (codebreaking) - the study of principles/ methods of deciphering ciphertext without knowing key Requirements \u2022 Two requirements for secure use of symmetric encryption: \u2022 a strong encryption algorithm \u2022 a secret key known only to sender / receiver Y = EK(X) X = DK(Y) \u2022 assume encryption algorithm is known \u2022 the security of symmetric encryption depends on the secrecy of the key \u2022 implies a secure channel to distribute key A strong encryption algorithm attacker encryption algorithm plaintext / enquiry cyphertext / response TA & Grader \u2022 TA Name: Faiyaz, Amir (Project, Review & Quiz) \u2022 Email: afaiyaz@ttu.edu \u2022 Reminder: Submit the names and emails of your group members to FALL 2024 CS5342 PROJECT GROUP NAMES.xlsx \u2022 Grader Name: Han, Namgyu (Homework, Quiz, Exam grading) \u2022 Email: Namgyu.Han@ttu.edu Know Your Threat Model \u2022 Threat model: A model of who your attacker is and what resources they have \u2022 One of the best ways to counter an attacker is to attack their reasons Story\u2026 \u2022 The bear race \u2022 Takeaway: Even if a defense is not perfect, it is important to always stay on top of best security measures I don\u2019t have to outrun the bear. I just have to outrun you Human Factors \u2022 The users \u2022 Users like convenience (ease of use) \u2022 If a security system is unusable, it will be unused \u2022 Users will find way to subvert security systems if it makes their lives easier \u2022 The programmers \u2022 Programmers make mistakes \u2022 Programmers use tools that allow them to make mistakes (e.g. C and C++) \u2022 Everyone else \u2022 Social engineering attacks exploit other people\u2019s trust and access for personal gain Design in security from the start \u2022 When building a new system, include security as part of the design considerations rather than patching it after the fact \u2022 A lot of systems today were not designed with security from the start, resulting in patches that don\u2019t fully fix the problem! \u2022 Keep these security principles in mind whenever you write code! Security Services and Mechanisms Supplementary materials \u2022 Internet Security Glossary, v2 \u2013 produced by Internet Society (ISOC) https://datatracker.ietf.org/doc/html/rfc4949 \u2022 X.800 \u2013 OSI network security https://www.itu.int/rec/dologin_pub.asp?lang=f&id=T-REC-X.800- 199103-I!!PDF-E&type=items Summary for Chapter 1 \u2022 Have learned: \u2022 Security requirements \u2022 Attack models \u2022 X.800 secure architecture, security services, mechanisms Review Questions \u2022 William Stallings (WS), \u201cNetwork Security Essentials\u201d, 6th Global Edition \u2022 RQ 1.1 - 1.3 \u2022 Prob 1.5 Security attack \u2022 Definition: any action that compromises the security of information owned by an organization \u2022 Two types of security attacks \u2022 Passive attack \u2022 Active attack Passive attack \u2022 i.e. eavesdropping on or monitoring of transmissions \u2022 Goal: obtain information being transmitted \u2022 release of message contents \u2022 traffic analysis \u2013 a promiscuous sniffer \u2022 Very difficult to detect \u2013 no alteration of the data \u2022 But easy to prevent, why? Active attack \u2022 active attack includes: \u2022 replay \u2022 Modification of messages \u2022 Denial of service \u2022 Masquerade Example: two points communication \u2022 Generic types of attacks Eavedropping Example of modification attack in 6LoWPAN Example: a group of attackers Know Your Threat Model \u2022 Threat model: A model of who your attacker is and what resources they have \u2022 One of the best ways to counter an attacker is to attack their reasons Example: adversary model \u2022 \u201cThe adversary is assumed to be intelligent and has limited number of resources. Before capturing the nodes, it exploits the various vulnerabilities of the networks. It knows the topology of the network, routing information. It aims to capture the sink node so as to disrupt the whole traffic. If it is not able to capture the sink node, it will capture the nearby nodes of the sink. It tries to disrupt the whole traffic of the network with minimum number of captured nodes. It is also assumed that the adversary tends to attack more on the nodes closer to the data sink than nodes that are far away\u201d No class on Wednesday \u2022 No class on Wednesday (Sept 18, 2024) due to the Job fair. Wish you good luck! \u2022 Reminder to form a project group by Sept. 9th, 2024 Project \u2022 Task1: OnDemand Professor Q&A Bot \u2022 Your task is to build a Q&A Bot over private data that answers questions about the network security course using the open-source alternatives to ChatGPT that can be run on your local machine. Data privacy can be compromised when sending data over the internet, so it is mandatory to keep it on your local system. \u2022 Your Q&A Bot should be able to understand user questions and provide appropriate answers from the local database, then the citations should be added (must be accomplished) if the response is from the internet, then the web references should be added. \u2022 Train your bot using network security lecture slides, network security textbook, and the Internet. \u2022 By using Wireshark capture data for Step 4's of the LLM workflow shown in Figure 1. Provide detailed explanations of the trace data. Also, Maintain a record of Step 1's prompt and its mapping to the trace data in Step 4's. \u2022 Task2: Quiz Bot \u2022 Your task is to build a quiz bot based on a network security course using the open-source alternatives to ChatGPT that can be run on your local machine. Data privacy can be compromised when sending data over the internet, so it is mandatory to keep it on your local system. \u2022 Two types of questions should be offered by the bot: randomly generated questions and specific topic questions and the answers should be pulled from the network security database. Train your bot using network security quizzes, lecture slides, network security textbook, and the Internet. \u2022 The quiz must include multiple-choice questions, true/false questions, and open-ended questions. \u2022 Finally, the bot should be able to provide feedback on the user's answers. Outline \u2022 Review \u2022 OSI Security Architecture \u2022 Attack model OSI Security Architecture OSI Security Architecture \u2022 International Telecommunication Union \u2013 Telecommunication (ITU-T) recommends X.800 \u2022 Security Architecture for Open Systems Interconnection (OSI) \u2022 Defines a systematic way of defining and providing security requirements \u2022 Used by IT managers and vendors in their products Security attacks Security mechanisms Security services a process (or a device incorporating such a process) to detect, prevent, or recover from an attack enhances the security of the data processing systems and the information transfers, such as policies Other Security Architectures \u2022 NIST, Cybersecurity Framework (CSF) \u2022 https://www.nist.gov/cyberframework \u2022 VIRTUAL WORKSHOP #2 | February 15, 2023 (9:00 AM \u2013 5:30 PM EST). Discuss potential significant updates to the CSF \u2022 https://www.nist.gov/news-events/events/2023/02/journey-nist-cybersecurity- framework-csf-20-workshop-2 \u2022 OWASP - Open Web Application Security Project \u2022 Web application security \u2022 OWASP Application Security Verification Standard (ASVS) - https://owasp.org/www-project-application-security-verification-standard/ \u2022 OWASP Web Security Testing - https://owasp.org/www-project-web-security-testing- guide/ \u2022 OWASP foundation Security attack \u2022 Definition: any action that compromises the security of information owned by an organization \u2022 Two types of security attacks \u2022 Passive attack \u2022 Active attack Network Security Introduction Chapter 1 Learning Objective \u2022 Introduce the security requirements \u2022 confidentiality \u2022 integrity \u2022 availability \u2022 Describe the X.800 security architecture for OSI Network Security Requirements Computer Network Security \u2022 Definition: The protection afforded to an automated information system in order to attain the application objectives to preserving the integrity, availability, and confidentiality of information system resources (includes hardware, software, firmware, information/data, and telecommunications). - NIST Computer Security Handbook Confidentiality \u2022 Data confidentiality: Assures that private or confidential information is not made available or disclosed to unauthorized individuals; \u2022 Privacy: Assures that individual's control or influence what information related to them may be collected and stored and by whom and to whom that information may be disclosed \u2022 i.e., student grade information Integrity \u2022 Data integrity: Assures that data (both stored and in transmitted packets) and programs are changed only in a specified and authorized manner; \u2022 System integrity: Assures that a system performs its intended function in an unimpaired manner, free from deliberate or inadvertent unauthorized manipulation of the system \u2022 i.e., a hospital patient\u2019s allergy information Availability \u2022 Availability: Assures that systems work promptly, and service is not denied to authorized users, ensuring timely and reliable access to and use of information \u2022 i.e., denial of service attack Other security requirements \u2022 Authenticity \u2022 Accountability \u2022 tracible data source, \u2022 fault isolation \u2022 intrusion detection and prevention, \u2022 recovery and legal action \u2022 system must keep records of their activities to permit later forensic analysis to trace security breaches or to aid in transaction disputes Question \u2022 What security requirements does a blockchain system have achieved? A Hyperledger \n\nStream Ciphers \u2022 process the message bit by bit (as a stream) \u2022 typically have a (pseudo) random stream key \u2022 combined (XOR) with plaintext bit by bit \u2022 randomness of stream key completely destroys any statistically properties in the message \u2022 Ci = Mi XOR StreamKeyi \u2022 what could be simpler!!!! \u2022 but must never reuse stream key \u2022 otherwise, can remove effect and recover messages, M\u2a01K\u2a01K = M Stream Cipher Properties \u2022 some design considerations are: \u2022 statistically random \u2022 depends on large enough key \u2022 large linear complexity \u2022 correlation immunity \u2022 confusion \u2022 diffusion How to generate Stream Key? \u2022 How to generate Stream Key? Stream Ciphers \u2022 Idea: replace \u201crand\u201d by \u201cpseudo rand\u201d \u2022 Use Pseudo Random Number Generator \u2022 A secure PRNG produces output that looks indistinguishable from random \u2022 An attacker who can\u2019t see the internal PRNG state can\u2019t learn any output \u2022 PRNG: {0,1}s \u00ae {0,1}n \u2022 expand a short (e.g., 128-bit) random seed into a long (typically unbounded) string that \u201clooks random\u201d \u2022 Secret key is the seed \u2022 Basic encryption method: Ekey[M] = M \u00c5 PRNG(key) Stream Ciphers \u2022 Protocol: Alice and Bob both seed a secure PRNG with their symmetric secret key, and then use the output as the key for stream key Alice Bob Seed(k) Seed(k) Generate(n) Generate(n) Plaintext Plaintext Ciphertext \u2295 \u2295 Stream Ciphers: Encrypting Multiple Messages \u2022 How do we encrypt multiple messages without key reuses? Alice Bob Seed(k) Seed(k) Generate(n) Generate(n) Plaintext Plaintext Ciphertext \u2295 \u2295 Stream Ciphers: Encrypting Multiple Messages \u2022 Solution: For each message, seed the PRNG with the key and a random IV, concatenated(\u201c|\u201d). Send the IV with the ciphertext Alice Bob Seed(k | IV) Seed(k | IV) Generate(n) Generate(n) Plaintext Plaintext Ciphertext \u2295 \u2295 IV IV Real-world example: RC4 \u2022 a proprietary cipher designed in 1987 \u2022 Extremely simple but effective! \u2022 Very fast - especially in software \u2022 Easily adapts to any key length, byte-oriented stream cipher \u2022 widely used (web SSL/TLS, wireless WEP, WAP) \u2022 A trade secret by RSA Security \u2022 uses that permutation to scramble input info processed a byte at a time RC4 Stream Cipher K RC4 (K|IV) 011010010111 \u2295 M C key (seed) key stream (pseudo random sequence) message ciphertext RC4 Key Schedule \u2022 starts with an array S of numbers: 0\u2026255 \u2022 use key to well and truly shuffle \u2022 S forms internal state of the cipher \u2022 given a key k of length I bytes Throw away T & K, retain S RSA Signatures \u2022 Sign(d, M): \u2022 Compute H(M)d mod n \u2022 Verify(e, n, M, sig) \u2022 Verify that H(M) \u2261 sige mod n RSA Digital Signature Algo Step1: Generate a hash value, or message digest, mHash from the message M to be signed Step2: Pad mHash with a constant value padding1 and pseudorandom value salt to form M\u2019 Step3: Generate hash value H from M\u2019 Step4: Generate a block DB consisting of a constant value padding 2 and salt Step5: Use the mask generating function MGF, which produces a randomized out-put from input H of the same length as DB Step 6: Create the encoded message (EM) block by padding H with the hexadecimal constant bc and the XOR of DB and output of MGF Step 7: Encrypt EM with RSA using the signer\u2019s private key RSA Signatures: Correctness Theorem: sige \u2261 H(M) mod N Proof: sige = [\ud835\udc3b\ud835\udc40\ud835\udc51 ]\ud835\udc52 \ud835\udc5a\ud835\udc5c\ud835\udc51 \ud835\udc41 = \ud835\udc3b(\ud835\udc40)\"# mod N RSA Signatures: Correctness Theorem: sige \u2261 H(M) mod N Proof: sige = [\ud835\udc3b\ud835\udc40\ud835\udc51 ]\ud835\udc52 \ud835\udc5a\ud835\udc5c\ud835\udc51 \ud835\udc41 = \ud835\udc3b(\ud835\udc40)\"# mod N = \ud835\udc3b(\ud835\udc40)$% & '( mod N = [\ud835\udc3b(\ud835\udc40)%(&)]$- \ud835\udc3b\ud835\udc40 mod N = H(M) mod N RSA Digital Signature: Security \u2022 Necessary hardness assumptions: \u2022 Factoring hardness assumption: Given n large, it is hard to find primes pq = n \u2022 Discrete logarithm hardness assumption: Given n large, hash, and hashd mod n, it is hard to find d \u2022 Salt also adds security \u2022 Even the same message and private key will get different signatures Hybrid Encryption \u2022 Issues with public-key encryption \u2022 Notice: We can only encrypt small messages because of the modulo operator \u2022 Notice: There is a lot of math, and computers are slow at math \u2022 Result: We don\u2019t use asymmetric for large messages \u2022 Hybrid encryption: Encrypt data under a randomly generated key K using symmetric encryption, and encrypt K using asymmetric encryption \u2022 EncAsym(PK, K); EncSym(K, large message) \u2022 Benefit: Now we can encrypt large amounts of data quickly using symmetric encryption, and we still have the security of asymmetric encryption Homework (Textbook) \u2013 no submission \u2022 Review Question: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6 \u2022 Problems: \u2022 prove correctness of RSA digital signature \u2022 3.14 & 3.15 Homework 2 - individual \u2022 For Chapter 3 \u2022 Deadline Friday, Nov. 1 before class \u2022 10% penalty per day for late submission Thank you! Network Security Chapter 4 Key Distribution Symmetric Key Distribution and User Authentication 4.2 Ways to achieve symmetric key distribution \u2022 A key could be selected by A and physically delivered to B \u2022 A third party could select the key and physically deliver it to A and B \u2022 If A and B have previously and recently used a key, one party could transmit the new key to the other, using the old key to encrypt the new key \u2022 If A and B each have an encrypted connection to a third-party C, C could deliver a key on the encrypted links to A and B Terminologies \u2022 Session key \u2022 Permanent key \u2022 key distribution center (KDC) \u2022 third party authority, centralized infrastructure \u2022 give permissions for two parties to communicate Diffie-Hellman Key Exchange Section 3.5 In class quiz on Wednesday \u2022 We will have a short quiz on Wednesday, Oct. 30, in class \u2022 A short quiz will cover the materials taught that day. \u2022 Please be on time for class to avoid missing the quiz questions. Authenticated Encryption: Definition \u2022 Authenticated encryption (AE): A scheme that simultaneously guarantees confidentiality and integrity (and authenticity, depending on your threat model) on a message \u2022 Two ways of achieving authenticated encryption: \u2022 Combine schemes that provide confidentiality with schemes that provide integrity \u2022 Use a scheme that is designed to provide confidentiality and integrity Scratchpad: Let\u2019s design it together \u2022 You can use: \u2022 An encryption scheme: Enc(K, M) and Dec(K, M) \u2022 An unforgeable MAC scheme (e.g. HMAC): MAC(K, M) \u2022 First attempt: Alice sends Enc(K1, M) and MAC(K2, M) \u2022 Integrity? Yes, attacker can\u2019t tamper with the MAC \u2022 Confidentiality? No, the MAC is not secure \u2022 Idea 1: Let\u2019s compute the MAC on the ciphertext instead of the plaintext: Enc(K1, M) and MAC(k2, Enc(K1, M)) \u2022 Integrity? Yes, attacker can\u2019t tamper with the MAC \u2022 Confidentiality? Yes, the MAC might leak info about the ciphertext, but that\u2019s okay \u2022 Idea 2: Let\u2019s encrypt the MAC too: Enc(K1, M || MAC(K2, M)) \u2022 Integrity? Yes, attacker can\u2019t tamper with the MAC \u2022 Confidentiality? Yes, everything is encrypted MAC-then-Encrypt or Encrypt-then-MAC? \u2022 Method 1: Encrypt-then-MAC \u2022 First compute Enc(K1, M) \u2022 Then MAC the ciphertext: MAC(K2, Enc(K1, M)) \u2022 Method 2: MAC-then-encrypt \u2022 First compute MAC(K2, M) \u2022 Then encrypt the message and the MAC together: Enc(k1, M || MAC(K2, M)) \u2022 Which is better? \u2022 In theory, both are secure if applied properly \u2022 MAC-then-encrypt has a flaw: You don\u2019t know if tampering has occurred until after decrypting \u2022 Attacker can supply arbitrary tampered input, and you always have to decrypt it \u2022 Passing attacker-chosen input through the decryption function can cause side-channel leaks \u2022 Always use encrypt-then-MAC because it\u2019s more robust to mistakes TLS 1.0 \u201cLucky 13\u201d Attack \u2022 TLS: A protocol for sending encrypted and authenticated messages over the Internet \u2022 TLS 1.0 uses MAC-then-encrypt: Enc(k1, M || MAC(k2, M)) \u2022 The encryption algorithm is AES-CBC \u2022 The Lucky 13 attack abuses MAC-then-encrypt to read encrypted messages \u2022 Guess a byte of plaintext and change the ciphertext accordingly \u2022 The MAC will error, but the time it takes to error is different depending on if the guess is correct \u2022 Attacker measures how long it takes to error in order to learn information about plaintext \u2022 TLS will send the message again if the MAC errors, so the attacker can guess repeatedly \u2022 Takeaways \u2022 Side channel attack: The algorithm is proved secure, but poor implementation made it vulnerable \u2022 Always encrypt-then-MAC Authenticated Encryption: Summary \u2022 Authenticated encryption: A scheme that simultaneously guarantees confidentiality and integrity (and authenticity) on a message \u2022 First approach: Combine schemes that provide confidentiality with schemes that provide integrity and authenticity \u2022 MAC-then-encrypt: Enc(K1, M || MAC(K2, M)) \u2022 Encrypt-then-MAC: MAC(K2, Enc(K1, M)) \u2022 Always use Encrypt-then-MAC because it's more robust to mistakes Digital Signature Digital Signatures \u2022 NIST FIPS PUB 186-4 - the result of a cryptographic transformation of data that, when properly implemented, provides a mechanism for verifying origin authentication, data integrity, and signatory non- repudiation \u2022 Based on asymmetric keys Digital Signatures \u2022 Asymmetric cryptography is good because we don\u2019t need to share a secret key \u2022 Digital signatures are the asymmetric way of providing integrity/authenticity to data \u2022 Assume that Alice and Bob can communicate public keys without David interfering Digital Signatures: Definition \u2022 Three parts: \u2022 KeyGen() \u2192 PK, SK: Generate a public/private keypair, where PK is the verify (public) key, and SK is the signing (secret) key \u2022 Sign(SK, M) \u2192 sig: Sign the message M using the signing key SK to produce the signature sig \u2022 Verify(PK, M, sig) \u2192 {0, 1}: Verify the signature sig on message M using the verify key PK and output 1 if valid and 0 if invalid \u2022 Properties: \u2022 Correctness: Verification should be successful for a signature generated over any message \u2022 Verify(PK, M, Sign(SK, M)) = 1 for all PK, SK \u2190 KeyGen() and M \u2022 Efficiency: Signing/verifying should be fast \u2022 Security: Same as for MACs except that the attacker also receives PK \u2022 Namely, no attacker can forge a signature for a message RSA Signature \u2022 KeyGen(): \u2022 Randomly pick two large primes, p and q \u2022 Compute n = pq \u2022 n is usually between 2048 bits and 4096 bits long \u2022 Choose e \u2022 Requirement: e is relatively prime to (p - 1)(q - 1) \u2022 Requirement: 2 < e < (p - 1)(q - 1) \u2022 Compute d = e-1 mod (p - 1)(q - 1) \u2022 Public key: n and e \u2022 Private key: d A Short Quiz \u2022 We will have a short quiz on Wednesday, Oct. 30, in class \u2022 A short quiz will cover the materials taught that day. Existentially unforgeable \u2022 A secure MAC is existentially unforgeable: without the key, an attacker cannot create a valid tag on a message \u2022 David cannot generate MAC(K, M') without K \u2022 David cannot find any M' \u2260 M such that MAC(K, M') = MAC(K, M) Example: HMAC \u2022 issued as RFC 2104 [1] \u2022 has been chosen as the mandatory-to-implement MAC for IP Security \u2022 Used in Transport Layer Security (TLS) and Secure Electronic Transaction (SET) [1] \u201cHMAC: Keyed-Hashing for Message Authentication\u201d, RFC 2104, https://datatracker.ietf.org/doc/html/rfc2104 HMAC(K, M) \u2022 will produce two keys to increase security \u2022 If key is longer than the desired size, we can hash it first, but be careful with using keys that are too much smaller, they have to have enough randomness in them \u2022 Output H[(K+ \u2295opad) || H[(K+ \u2295ipad) || M]] Example: HMAC \u2022 HMAC(K, M): \u2022 Output H[(K+ \u2295opad) || H[(K+ \u2295ipad) || M]] \u2022 Use K to derive two different keys \u2022 opad (outer pad) is the hard-coded byte 0x5c repeated until it\u2019s the same length as K+ \u2022 ipad (inner pad) is the hard-coded byte 0x36 repeated until it\u2019s the same length as K+ \u2022 As long as opad and ipad are different, you\u2019ll get two different keys \u2022 For paranoia, the designers chose two very different bit patterns, even though they theoretically need only differ in one bit HMAC A B A \u2a01B 0 0 0 0 1 1 1 0 1 1 1 0 K+ = !H \ud835\udc3e \ud835\udc3e \ud835\udc56\ud835\udc60 \ud835\udc59\ud835\udc4e\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc5f \ud835\udc61\u210e\ud835\udc4e\ud835\udc5b \ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58 \ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52 \ud835\udc3e \ud835\udc5c\ud835\udc61\u210e\ud835\udc52\ud835\udc5f\ud835\udc64\ud835\udc56\ud835\udc60\ud835\udc52 ipad = 00110110 , repeat b/8 times opad = 01011100, repeat b/8 times HMAC procedure \u2022 Step 1: Append zeros to the left end of K to create a b-bit string K+ (e.g., if K is of length 160 bits and b = 512, then K will be appended with 44 zero bytes); \u2022 Step 2: XOR (bitwise exclusive-OR) K+ with ipad to produce the b-bit block Si; \u2022 Step 3: Append M to Si; \u2022 Step 4: Apply H to the stream generated in step 3; \u2022 Step 5: XOR K+ with opad to produce the b-bit block So; \u2022 Step 6: Append the hash result from step 4 to So; \u2022 Step 7: Apply H to the stream generated in step 6 and output the result. HMAC Properties \u2022 HMAC(K, M) = H[(K+ \u2295opad) || H((K+ \u2295ipad) || M]] \u2022 HMAC is a hash function, so it has the properties of the underlying hash too \u2022 It is collision resistant \u2022 Given HMAC(K, M), an attacker can\u2019t learn M \u2013 one way \u2022 If the underlying hash is secure, HMAC doesn\u2019t reveal M, but it is still deterministic \u2022 You can\u2019t verify a tag T if you don\u2019t have K \u2022 This means that an attacker can\u2019t brute-force the message M without knowing K MACs: Summary \u2022 Inputs: a secret key and a message \u2022 Output: a tag on the message \u2022 A secure MAC is unforgeable: Even if David can trick Alice into creating MACs for messages that David chooses, David cannot create a valid MAC on a message that she hasn't seen before \u2022 Example: HMAC(K, M) = H((K+ \u2295opad) || H((K+ \u2295ipad) || M)) \u2022 MACs do not provide confidentiality Do MACs provide integrity? \u2022 Do MACs provide integrity? \u2022 Yes. An attacker cannot tamper with the message without being detected \u2022 Do MACs provide authenticity? \u2022 It depends on your threat model \u2022 If only two people have the secret key, MACs provide authenticity: it has a valid MAC, and it\u2019s not from me, so it must be from the other person \u2022 More than one secret key, If a message has a valid MAC, you can be sure it came from someone with the secret key, but you can\u2019t narrow it down to one person \u2022 Do MACs provide confidentiality? Authenticated Encryption Authenticated Encryption: Definition \u2022 Authenticated encryption (AE): A scheme that simultaneously guarantees confidentiality and integrity (and authenticity, depending on your threat model) on a message \u2022 Two ways of achieving authenticated encryption: \u2022 Combine schemes that provide confidentiality with schemes that provide integrity \u2022 Use a scheme that is designed to provide confidentiality and integrity Length Extension Attacks \u2022 Length extension attack: Given H(x) and the length of x, but not x, an attacker can create H(x || m) for any m of the attacker\u2019s choosing \u2022 Length extension attack - Wikipedia \u2022 SHA-256 (256-bit version of SHA-2) is vulnerable \u2022 SHA-3 is not vulnerable Does hashes provide integrity? \u2022 It depends on your threat model \u2022 Scenario \u2022 Mozilla publishes a new version of Firefox on some download servers \u2022 Alice downloads the program binary \u2022 How can she be sure that nobody tampered with the program? \u2022 Idea: use cryptographic hashes \u2022 Mozilla hashes the program binary and publishes the hash on its website \u2022 Alice hashes the binary she downloaded and checks that it matches the hash on the website \u2022 If Alice downloaded a malicious program, the hash would not match (tampering detected!) \u2022 An attacker can\u2019t create a malicious program with the same hash (collision resistance) \u2022 Threat model: We assume the attacker cannot modify the hash on the website \u2022 We have integrity, as long as we can communicate the hash securely Do hashes provide integrity? \u2022 It depends on your threat model \u2022 Scenario \u2022 Alice and Bob want to communicate over an insecure channel \u2022 David might tamper with messages \u2022 Idea: Use cryptographic hashes \u2022 Alice sends her message with a cryptographic hash over the channel \u2022 Bob receives the message and computes a hash on the message \u2022 Bob checks that the hash he computed matches the hash sent by Alice \u2022 Threat model: David can modify the message and the hash \u2022 No integrity! Man-in-the-middle attack Alice M\u2019 MD\u2019 M MD M MD M\u2019 MD\u2019 Bob David Do hashes provide integrity? \u2022 It depends on your threat model \u2022 If the attacker can modify the hash, hashes don\u2019t provide integrity \u2022 Main issue: Hashes are unkeyed functions \u2022 There is no secret key being used as input, so any attacker can compute a hash on any value Solutions \u2022 A message digest created using a secret symmetric key is known as a Message Authentication Code (MAC), because it can provide assurance that the message has not been modified \u2022 The sender can also generate a message digest and then encrypt the digest using the private key of an asymmetric key pair, forming a digital signature. The signature must then be verified by the receiver through comparing it with a locally generated digest Hashes: Summary \u2022 Map arbitrary-length input to fixed-length output \u2022 Output is deterministic \u2022 Security properties \u2022 One way: Given an output y, it is infeasible to find any input x such that H(x) = y. \u2022 Second preimage resistant: Given an input x, it is infeasible to find another input x' \u2260 x such that H(x) = H(x'). \u2022 Collision resistant: It is infeasible to find any pair of inputs x' \u2260 x such that H(x) = H(x\u2019). \u2022 Randomized output \u2022 Some hashes are vulnerable to length extension attacks \u2022 Hashes don\u2019t provide integrity (unless you can publish the hash securely) Message Authentication Code Message authentication code (MAC) \u2022 generated by an algorithm that creates a small fixed-sized block \u2022 depending on both message and some key \u2022 not be reversible \u2022 MACM = F(KAB, M) \u2022 appended to message as a signature \u2022 receiver performs same computation on message and checks it matches the MAC \u2022 provides assurance that message is unaltered and comes from sender MACs: Usage \u2022 Alice wants to send M to Bob, but doesn\u2019t want David to tamper with it \u2022 Alice sends M and T = MAC(K, M) to Bob \u2022 Bob receives M and T \u2022 Bob computes MAC(K, M) and checks that it matches T \u2022 If the MACs match, Bob is confident the message has not been tampered with (integrity) MACs: Definition \u2022 Two parts: \u2022 KeyGen() \u2192 K: Generate a key K \u2022 MAC(K, M) \u2192 T: Generate a tag T for the message M using key K \u2022 Inputs: A secret key and an arbitrary-length message \u2022 Output: A fixed-length tag on the message \u2022 Properties \u2022 Correctness: Determinism \u2022 Note: Some more complicated MAC schemes have an additional Verify(K, M, T) function that don\u2019t require determinism, but this is out of scope \u2022 Efficiency: Computing a MAC should be efficient \u2022 Security: existentially unforgeable under chosen plaintext attack Mid-term Exam \u2022 Nov. 6, 2024 (Wednesday), 12:00 pm \u2013 12:50 pm, in class \u2022 Closed book, but you're allowed to bring one cheat sheet (1 A4-sized paper) \u2022 Chapter 1 \u2013 3 \u2022 Will have a review class on Nov. 1st , during class Message Authentication Message authentication \u2022 message authentication is concerned with: \u2022 protecting the integrity of a message \u2022 validating identity of originator \u2022 non-repudiation of origin (dispute resolution) \u2022 then three alternative functions used: \u2022 message encryption \u2013 symmetric \u2022 message authentication code (MAC) \u2022 digital signature Message encryption \u2022 Symmetric message encryption by itself also provides a measure of authentication \u2022 if symmetric encryption is used then: \u2022 receiver knows sender must have created it \u2022 since only sender and receiver know key used \u2022 know content cannot be altered Homework 1 questions \u2022 Symmetric Block Cypher provides authentication and confidentiality \u2022 Ans: True Message encryption \u2022 if public-key encryption is used: \u2022 encryption provides no confidence of sender \u2022 since anyone potentially knows public-key \u2022 so, need to recognize corrupted messages \u2022 however, if \u2022 sender signs message using their private-key \u2022 then encrypts with recipients\u2019 public key \u2022 have both secrecy and authentication \u2022 but at cost of two public-key uses on message Reasons to avoid encryption authentication \u2022 Encryption software is quite slow \u2022 Encryption hardware costs are nonnegligible \u2022 Encryption hardware is optimized toward large data sizes \u2022 An encryption algorithm may be protected by a patent Hash Function Hash functions \u2022 Hash function: h = H(M) \u2022 M can be of any size \u2022 h is always of fixed size \u2022 Typically, h << size(M) One use case - using hash function \u2022 Initialization: A and B share a common secret, SAB \u2022 Message, M \u2022 A calculates MDM = H (SAB || M) \u2022 B recalculates MD\u2019M, and check \u2022 MD\u2019M = MDM Requirements for secure hash functions \u2022 1. can be applied to any sized message M \u2022 2. produces fixed-length output h \u2022 3. is easy to compute h=H(M) for any message M \u2022 4. given h is infeasible to find x s.t. H(x)=h \u2022 one-way property or preimage resistance \u2022 5. given x is infeasible to find x\u2019 s.t. H(x\u2019)=H(x) \u2022 weak collision resistance or second pre-image resistant \u2022 6. infeasible to find any pair of x,x\u2019 s.t. H(x\u2019)=H(x) \u2022 strong collision resistance Hash Function: Collision Resistance \u2022 Collision: Two different inputs with the same output \u2022 x \u2260 x' and H(x) = H(x') \u2022 Can we design a hash function with no collisions? \u2022 No, because there are more inputs than outputs (pigeonhole principle) \u2022 However, we want to make finding collisions infeasible for an attacker \u2022 Collision resistance: It is infeasible to (i.e. no polynomial time attacker can) find any pair of inputs x' \u2260 x such that H(x) = H(x') Secure hash function \u2022 A hash function that satisfies the first five properties is referred to as a weak hash function \u2022 Security: random/unpredictability, no predictable patterns for how changing the input affects the output \u2022 Changing 1 bit in the input causes the output to be completely different \u2022 Also called \u201crandom oracle\u201d assumption Secure hash function \u2022 A hash function that satisfies the first five properties is referred to as a weak hash function \u2022 Security: random/unpredictability, no predictable patterns for how changing the input affects the output \u2022 Changing 1 bit in the input causes the output to be completely different \u2022 Also called \u201crandom oracle\u201d assumption \u2022 A message digest \u2022 a cryptographic hash function containing a string of digits created by a one- way hashing formula \u2022 provides data integrity \u2022 Examples: SHA-1 (Secure Hash Algorithm 1), SHA-2, SHA-3, MD5 Hash Function: Examples \u2022 MD5 \u2022 Output: 128 bits \u2022 Security: Completely broken \u2022 SHA-1 \u2022 Output: 160 bits \u2022 Security: Completely broken in 2017 \u2022 Was known to be weak before 2017, but still used sometimes \u2022 SHA-2 \u2022 Output: 256, 384, or 512 bits (sometimes labeled SHA-256, SHA-384, SHA-512) \u2022 Not currently broken, but some variants are vulnerable to a length extension attack \u2022 Current standard \u2022 SHA-3 (Keccak) \u2022 Output: 256, 384, or 512 bits \u2022 Current standard (not meant to replace SHA-2, just a different construction) Length Extension Attacks \u2022 Length extension attack: Given H(x) and the length of x, but not x, an attacker can create H(x || m) for any m of the attacker\u2019s choosing \u2022 Length extension attack - Wikipedia \u2022 SHA-256 (256-bit version of SHA-2) is vulnerable \u2022 SHA-3 is not vulnerable Attack approaches \u2022 Mathematical attacks: several approaches, all equivalent in effort to factoring the product of two primes. The defense against mathematical attacks is to use a large key size. \u2022 Timing attacks: These depend on the running time of the decryption algorithm \u2022 Chosen ciphertext attacks: this type of attacks exploits properties of the RSA algorithm by selecting blocks of data. These attacks can be thwarted by suitable padding of the plaintext, such as PKCS1 V1.5 in SSL A simple attack on textbook RSA \u2022 Session-key K is 64 bits. View K \u00ce {0,\u2026,264} \u2022 Eavesdropper sees: C = Ke (mod N) . \u2022 Suppose K = K1\u00d7K2 where K1, K2 < 234 . \u2022 Then: C/K1 e = K2 e (mod N) \u2022 Build table: C/1e, C/2e, C/3e, \u2026, C/234e . time: 234 For K2 = 0,\u2026, 234 test if K2 e is in table. time: 234\u00d734 \u2022 Attack time: \u00bb240 << 264 Web Browser Web Server Random session key K d Client Hello Server Hello (e, N) C = RSA (K) Take-home exercise \u2013 no need to submit \u2022 SW textbook (6th edition) problems: 3.14 & 3.15 Homomorphic encryption \u2022 Encryption scheme that allows computation on ciphertexts \u2022 an extension of public-key encryption scheme that allows anyone in possession of the public key to perform operations on encrypted data without access to the decryption key \u2022 Partially Homomorphic Encryption: Initial public-key systems that allow this for either addition or multiplication, but not both. \u2022 i.e. RSA \u2022 Fully homomorphic encryption (FHE) Application of homomorphic encryption \u2022 One Use case: cloud computing \u2022 A weak computational device Alice (e.g., a mobile phone or a laptop) wishes to perform a computationally heavy task, beyond her computational means. She can delegate it to a much stronger (but still feasible) machine Bob (the cloud, or a supercomputer) who offers the service of doing so. The problem is that Alice does not trust Bob, who may give the wrong answer due to laziness, fault, or malice. E (Pk, data) E (Pk, f(data)) RSA reading materials \u2022 A Method for Obtaining Digital Signatures and Public-Key Cryptosystems RSA example 1. Select primes: p=17 & q=11 2. Compute n = pq =17\u00d711=187 3. Compute \u00f8(n)=(p\u20131)(q-1)=16\u00d710=160 4. Select e : gcd(e,160)=1; choose e=7 5. Determine d: de=1 mod 160 and d < 160 Value is d=23 since 23\u00d77=161= 10\u00d7160+1 6. Publish public key pk={7,187} 7. Keep secret private key sk={23,17,11} RSA use \u2022 to encrypt a message M the sender: \u2022 obtains public key of recipient pk={e,n} \u2022 computes: C=Me mod n, where 0\u2264M<n \u2022 to decrypt the ciphertext C the owner: \u2022 uses their private key sk={d,p,q} \u2022 computes: M=Cd mod n \u2022 note that the message M must be smaller than the modulus n (block if needed) Plaintext Ciphertext C = \ud835\udc40! pk={e,n} sk={d,p,q} RSA example continue \u2022 sample RSA encryption/decryption is: \u2022 given message M = 88 ( 88<187) \u2022 encryption: C = 887 mod 187 = 11 \u2022 decryption: M = 1123 mod 187 = 88 Example of RSA algorithm RSA key generation \u2022 users of RSA must: \u2022 determine two primes at random - p, q \u2022 select either e or d and compute the other \u2022 primes p,q must not be easily derived from modulus n=p.q \u2022 means must be sufficiently large \u2022 typically guess and use probabilistic test \u2022 exponents e, d are inverses, so use Inverse algorithm to compute the other Correctness of RSA \u2022 Euler\u2019s theorem: if gcd (M, n) = 1, then \ud835\udc40!(#) = 1 mod n. Here \u03c6(n) is Euler\u2019s totient function: the number of integers in {1, 2, . . ., n-1} which are relatively prime to n. When n is a prime, this theorem is just Fermat\u2019s little theorem M\u2019 = \ud835\udc36% mod n = \ud835\udc40&% mod n = \ud835\udc40(! # )* mod n = [\ud835\udc40!(#)](, \ud835\udc40 mod n = M mod n Attack approaches \u2022 Mathematical attacks: several approaches, all equivalent in effort to factoring the product of two primes. The defense against mathematical attacks is to use a large key size. \u2022 Timing attacks: These depend on the running time of the decryption algorithm \u2022 Chosen ciphertext attacks: this type of attacks exploits properties of the RSA algorithm by selecting blocks of data. These attacks can be thwarted by suitable padding of the plaintext, such as PKCS1 V1.5 in SSL A simple attack on textbook RSA \u2022 Session-key K is 64 bits. View K \u00ce {0,\u2026,264} \u2022 Eavesdropper sees: C = Ke (mod N) . \u2022 Suppose K = K1\u00d7K2 where K1, K2 < 234 . \u2022 Then: C/K1 e = K2 e (mod N) \u2022 Build table: C/1e, C/2e, C/3e, \u2026, C/234e . time: 234 For K2 = 0,\u2026, 234 test if K2 e is in table. time: 234\u00d734 \u2022 Attack time: \u00bb240 << 264 Web Browser Web Server Random session key K d Client Hello Server Hello (e, N) C = RSA (K) Public-Key Cryptography Algorithm (RSA) RSA Public-key encryption \u2022 by Rivest, Shamir & Adleman of MIT in 1977 \u2022 currently the \u201cwork horse\u201d of Internet security \u2022 most public key infrastructure (PKI) products \u2022 SSL/TLS: certificates and key-exchange \u2022 secure e-mail: PGP, Outlook, \u2026. \u2022 based on exponentiation in a finite (Galois) field over integers modulo a prime \u2022 exponentiation takes O((log n)3) operations (easy) \u2022 security due to cost of factoring large integer numbers \u2022 factorization takes O(e log n log log n) operations (hard) \u2022 uses large integers (eg. 1024 bits) RSA key setup \u2022 each user generates a public/private key pair by: \u2022 selecting two large primes at random - p, q \u2022 computing their system modulus n=p!q \u2022 note \u00f8(n)=(p-1)(q-1) \u2022 selecting at random the encryption key e \u2022 where 1<e<\u00f8(n), gcd(e,\u00f8(n))=1 \u2022 solve following equation to find decryption key d \u2022 ed=1 mod \u00f8(n) \u2022 publish their public encryption key: pk={e,n} \u2022 keep secret private decryption key: sk={d,p,q} RSA example 1. Select primes: p=17 & q=11 2. Compute n = pq =17\u00d711=187 3. Compute \u00f8(n)=(p\u20131)(q-1)=16\u00d710=160 4. Select e : gcd(e,160)=1; choose e=7 5. Determine d: de=1 mod 160 and d < 160 Value is d=23 since 23\u00d77=161= 10\u00d7160+1 6. Publish public key pk={7,187} 7. Keep secret private key sk={23,17,11} Encryption steps \u2022 step1: generate a pair of keys \u2022 step2: keep the private key / secret key (SK) and distribute the public key (PK) \u2013 place PK in a public register or other accessible file \u2022 step3: Bob encrypts the message with Alice\u2019s PK \u2022 step4: upon receiving the ciphertext (CT), Alice decrypt CT with SK Public-Key Encryption: Definition \u2022 Three parts: \u2022 KeyGen() \u2192 PK, SK: Generate a public/private keypair, where PK is the public key, and SK is the private (secret) key \u2022 Enc(PK, M) \u2192 C: Encrypt a plaintext M using public key PK to produce ciphertext C \u2022 Dec(SK, C) \u2192 M: Decrypt a ciphertext C using secret key SK \u2022 Properties \u2022 Correctness: Decrypting a ciphertext should result in the message that was originally encrypted \u2022 Dec(SK, Enc(PK, M)) = M for all PK, SK \u2190 KeyGen() and M \u2022 Efficiency: Encryption/decryption should be fast \u2022 Security: 1. Alice (the challenger) just gives Eve (the adversary) the public key, and Eve doesn\u2019t request encryptions. Eve cannot guess out anything; 2. computationally infeasible to recover M with PK and ciphertext Public-Key Cryptography - Signature Review Private Key Public Key Signature Encryption Public-Key application \u2022 can classify uses into 3 categories: \u2022 encryption/decryption (provide secrecy) \u2022 digital signatures (provide authentication) \u2022 key exchange (of session keys) \u2022 some algorithms are suitable for all uses; others are specific to one \u2022 Either of the two related keys can be used for encryption, with the other used for decryption Security of Public Key Schemes \u2022 Keys used are very large (>512bits) \u2022 like private key schemes brute force exhaustive search attack is always theoretically possible \u2022 Security relies on a large enough difference in difficulty between easy (en/decrypt) and hard (cryptanalyze) problems \u2022 more generally the hard problem is known, it\u2019s just made too hard to do in practice \u2022 Requires the use of very large numbers, hence is slow compared to private/symmetric key schemes Public-Key Cryptography \u2022 In public-key schemes, each person has two keys \u2022 Public key: Known to everybody \u2022 Private key: Only known by that person \u2022 Keys come in pairs: every public key corresponds to one private key \u2022 Uses number theory \u2022 Examples: Modular arithmetic, factoring, discrete logarithm problem, Elliptic logs over Elliptic Curves \u2022 Contrast with symmetric-key cryptography (uses XORs and bit-shifts) \u2022 Messages are numbers \u2022 Contrast with symmetric-key cryptography (messages are bit strings) Public-key Cryptography \u2022 Benefit: \u2022 Drawback: \u2022 Benefit: No longer need to assume that Alice and Bob already share a secret \u2022 Drawback: Much slower than symmetric-key cryptography \u2022 Number theory calculations are much slower than XORs and bit-shifts Reading materials \u2022 Encryption: Strengths and Weaknesses of Public-key Cryptography \u2022 Public-key cryptography is a public invention due to Whitfield Diffie & Martin Hellman at Stanford Uni in 1976 Public-key cryptography \u2022 public-key/two-key/asymmetric cryptography involves the use of two keys: \u2022 a public-key, which may be known by anybody, and can be used to encrypt messages, and verify signatures \u2022 a private-key, known only to the recipient, used to decrypt messages, and sign (create) signatures \u2022 is asymmetric because \u2022 Not the same key \u2022 those who encrypt messages or verify signatures cannot decrypt messages or create signatures Public-Key Encryption \u2022 Everybody can encrypt with the public key \u2022 Only the recipient can decrypt with the private key Public-Key Cryptography - Encryption Encryption steps \u2022 step1: generate a pair of keys \u2022 step2: keep the private key / secret key (SK) and distribute the public key (PK) \u2013 place PK in a public register or other accessible file \u2022 step3: Bob encrypts the message with Alice\u2019s PK \u2022 step4: upon receiving the ciphertext (CT), Alice decrypt CT with SK An example of key distribution SSH key-based client authentication. Source: Peiyue and Yuanyuan 2021. 1.Peiyue, G. and F. Yuanyuan. 2021. \"What Is SSH?\" Info-Finder, Huawei, July 22. Updated 2021-12-14. Accessed 2023-04-18. RC4 Stream Cipher K RC4 (K|IV) 011010010111 \u2295 M C key (seed) key stream (pseudo random sequence) message ciphertext RC4 Key Schedule \u2022 starts with an array S of numbers: 0\u2026255 \u2022 use key to well and truly shuffle \u2022 S forms internal state of the cipher \u2022 given a key k of length I bytes Throw away T & K, retain S RC4 Encryption \u2022 encryption continues shuffling array values \u2022 sum of shuffled pair selects \"stream key\" value \u2022 XOR with next byte of message to en/decrypt RC4 RC4 Security \u2022 claimed secure against known attacks \u2022 since RC4 is a stream cipher, must never reuse a key \u2022 have a concern with WEP, but due to key handling rather than RC4 itself \u2022 RC4 Biases: It is extensively studied, not a completely secure PRNG, first part of output biased, when used as stream cipher, should use RC4-Drop[n] \u2022 Which drops first n bytes before using the output \u2022 Conservatively, set n=3072 Summary \u2013 Chapter 2 \u2022 Symmetric block cipher \u2022 DES, 3DES \u2022 AES \u2022 Random number \u2022 true random number \u2022 pseudorandom number \u2022 Stream cipher \u2022 The security of symmetric encryption depends on the secrecy of the key \u2022 Symmetric encryption: pros and cons Modular Arithmetic \u2022 Definition (congruent modulo): \u2022 given b \u2013 a = km for some k \ud835\udf16\ud835\udc4d, then a \u2261\ud835\udc4f(mod m) \u2022 Given a \u2261\ud835\udc4f(mod m) and c \u2261\ud835\udc51(mod m), then \u2022 a + b \u2261c + d (mod m) \u2022 a - b \u2261c - d (mod m) \u2022 a + c \u2261b + d (mod m) \u2022 a \u00d7 c \u2261b \u00d7 d (mod m) \u2022 ak \u2261bk (mod m) \u2022 ka = kb (mod m) \u2022 p(a) \u2261p(b) (mod m), any polynomial p(x) with integer coefficients \u2022 A \u2a01\ud835\udc35\u2a01\ud835\udc35= A Thank you! Network Security Chapter 3 Public-Key Cryptography and Message Authentication Public-Key Cryptography Conventional cryptography \u2022 traditional private/secret/single-key cryptography uses one key \u2022 shared by both sender and receiver \u2022 if this key is disclosed, communications are compromised \u2022 also is symmetric, parties are equal Pros and cons \u2022 Pros: \u2022 Encryption is fast for large amounts of data \u2022 Provide the same level of security with a shorter encryption key \u2022 By now, it\u2019s unbreakable to quantum computing \u2022 Cons \u2022 Key distribution assumes a secure channel \u2022 Does not protect sender from receiver forging a message & claiming it\u2019s sent by sender \u2022 It does not scale well for large networks. It requires a separate key for each pair of communicating parties, which can result in a large number of keys to manage and protect. Homework 1 - individual \u2022 Chapter 1 & 2 \u2022 Deadline: Tuesday, October 8, 11:59 PM \u2022 Submit your homework via the provided link. \u2022 The Google submission timestamp will be considered final. \u2022 A 10% penalty will be applied for each day of late submission. Review & Quiz I \u2022 Chapter 1 & 2 \u2022 Wednesday (Oct. 9, 2024), in class \u2022 Please ensure your participation \u2022 No make-up quiz Pseudorandom Number Generators (PRNGs) \u2022 True randomness is expensive \u2022 Pseudorandom number generator (PRNGs): An algorithm that uses a little bit of true randomness to generate a lot of random-looking output \u2022 Also called deterministic random bit generators (DRBGs) \u2022 PRNGs are deterministic: Output is generated according to a set algorithm \u2022 However, for an attacker who can\u2019t see the internal state, the output is computationally indistinguishable from true randomness PRNG: Definition \u2022 A PRNG has two functions: \u2022 PRNG.Seed(randomness): Initializes the internal state using the entropy \u2022 Input: Some truly random bits \u2022 PRNG.Generate(n): Generate n pseudorandom bits \u2022 Input: A number n \u2022 Output: n pseudorandom bits \u2022 Updates the internal state as needed \u2022 Properties \u2022 Correctness: Deterministic \u2022 Efficiency: Efficient to generate pseudorandom bits \u2022 Security: Indistinguishability from random \u2022 Rollback resistance: cannot deduce anything about any previously-generated bit Example construction of PRNG \u2022 Using block cipher in Counter (CTR) mode: \u2022 If you want m random bits, and a block cipher with Ek has n bits, apply the block cipher m/n times and concatenate the result: \u2022 PRNG.Seed(K | IV) = Ek(IV, 1) | Ek(IV, 2) | Ek(IV, 3) \u2026 Ek(IV, ceil(m/n)), \u2022 | is concatenation \u2022 Initialization vector (IV) / Nonce \u2013 typically is random or pseudorandom Randomness, PRNG output PRNG: Security \u2022 Can we design a PRNG that is truly random? \u2022 A PRNG cannot be truly random \u2022 The output is deterministic given the initial seed \u2022 A secure PRNG is computationally indistinguishable from random to an attacker \u2022 Game: Present an attacker with a truly random sequence and a sequence outputted from a secure PRNG \u2022 An attacker should be able to determine which is which with probability \u22480 \u2022 Equivalence: An attacker cannot predict future output of the PRNG Create pseudorandom numbers \u2022 Truly random numbers are impossible with any program! \u2022 However, we can generate seemingly random numbers, called pseudorandom numbers \u2022 The function rand() returns a non-negative number between 0 and RAND_MAX \u2022 For C, it is defined in stdlib.h \u2022 arc4random() is a function available in some operating systems (primarily BSD-based systems like macOS and FreeBSD) that generates random numbers. It is part of the C standard library and provides a more secure and higher-quality source of random numbers compared to rand() PRNGs: Summary \u2022 True randomness requires sampling a physical process \u2022 PRNG: An algorithm that uses a little bit of true randomness to generate a lot of random-looking output \u2022 Seed(entropy): Initialize internal state \u2022 Generate(n): Generate n bits of pseudorandom output \u2022 Security: computationally indistinguishable from truly random bits Stream Ciphers Stream Ciphers \u2022 process the message bit by bit (as a stream) \u2022 typically have a (pseudo) random stream key \u2022 combined (XOR) with plaintext bit by bit \u2022 randomness of stream key completely destroys any statistically properties in the message \u2022 Ci = Mi XOR StreamKeyi \u2022 what could be simpler!!!! \u2022 but must never reuse stream key \u2022 otherwise, can remove effect and recover messages, M\u2a01K\u2a01K = M Properties of Random Numbers \u2022 Randomness \u2022 Uniformity \u2022 distribution of bits in the sequence should be uniform \u2022 Independence \u2022 no one subsequence in the sequence can be inferred from the others \u2022 Unpredictable \u2022 satisfies the \"next-bit test\u201c Entropy \u2022 A measure of uncertainty \u2022 In other words, a measure of how unpredictable the outcomes are \u2022 High entropy = unpredictable outcomes = desirable in cryptography \u2022 The uniform distribution has the highest entropy (every outcome equally likely, e.g. fair coin toss) \u2022 Usually measured in bits (so 3 bits of entropy = uniform, random distribution over 8 values) Entropy of an information source True random numbers generators \u2022 Several sources of randomness \u2013 natural sources of randomness \u2022 decay times of radioactive materials \u2022 electrical noise from a resistor or semiconductor \u2022 radio channel or audible noise \u2022 keyboard timings \u2022 disk electrical activity \u2022 mouse movements \u2022 Physical unclonable function (PUF) \u2022 Some are better than others Combining sources of randomness \u2022 Suppose r1, r2, \u2026, rk are random numbers from different sources. E.g., r1 = electrical noise from a resistor or semiconductor r2 = sample of hip-hop music on radio r3 = clock on computer b = r1\u2295r2\u2295\u2026\u2295rk If any one of r1, r2, \u2026, rk is truly random, then so is b Many poor sources + 1 good source = good entropy Pseudorandom Number Generators (PRNGs) \u2022 True randomness is expensive \u2022 Pseudorandom number generator (PRNGs): An algorithm that uses a little bit of true randomness to generate a lot of random-looking output \u2022 Also called deterministic random bit generators (DRBGs) \u2022 PRNGs are deterministic: Output is generated according to a set algorithm \u2022 However, for an attacker who can\u2019t see the internal state, the output is computationally indistinguishable from true randomness Random and Pseudorandom Numbers When to use random numbers? \u2022 Generation of a stream key for symmetric stream cipher \u2022 Generation of keys for public-key algorithms \u2022 RSA public-key encryption algorithm (described in Chapter 3) \u2022 Generation of a symmetric key for use as a temporary session key \u2022 used in a number of networking applications, such as Transport Layer Security (Chapter 5), Wi-Fi (Chapter 6), e-mail security (Chapter 7), and IP security (Chapter 8) \u2022 In a number of key distribution scenarios \u2022 Kerberos (Chapter 4) Two types of random numbers \u2022 True random numbers: \u2022 generated in non-deterministic ways. They are not predictable and repeatable \u2022 Pseudorandom numbers: \u2022 appear random, but are obtained in a deterministic, repeatable, and predictable manner Properties of Random Numbers \u2022 Randomness \u2022 Uniformity \u2022 distribution of bits in the sequence should be uniform \u2022 Independence \u2022 no one subsequence in the sequence can be inferred from the others \u2022 Unpredictable \u2022 satisfies the \"next-bit test\u201c Entropy \u2022 A measure of uncertainty \u2022 In other words, a measure of how unpredictable the outcomes are \u2022 High entropy = unpredictable outcomes = desirable in cryptography \u2022 The uniform distribution has the highest entropy (every outcome equally likely, e.g. fair coin toss) \u2022 Usually measured in bits (so 3 bits of entropy = uniform, random distribution over 8 values) Entropy of an information source AES Specification \u2022 symmetric block cipher \u2022 128-bit data, 128/192/256-bit keys \u2022 stronger & faster than Triple-DES \u2022 provide full specification & design details \u2022 both C & Java implementations \u2022 NIST have released all submissions & unclassified analyses https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards- and-Guidelines/documents/aes-development/Rijndael-ammended.pdf The AES Cipher - Rijndael \u2022 an iterative rather than feistel cipher \u2022 treats data in 4 groups of 4 bytes \u2022 operates an entire block in every round \u2022 designed to be: \u2022 resistant against known-plaintext attacks \u2022 speed and code compactness on many CPUs \u2022 design simplicity Rijndael \u2022 processes data as 4 groups of 4 bytes (state) = 128 bits \u2022 has 10/12/14 rounds in which state undergoes: \u2022 byte substitution (1 S-box used on every byte) \u2022 shift rows (permute bytes row by row) \u2022 mix columns (alter each byte in a column as a function of all of the bytes in the column) \u2022 add round key (XOR state with key material) \u2022 128-bit keys \u2013 10 rounds, 192-bit keys \u2013 12 rounds, 256-bit keys \u2013 14 rounds AES Encryption and Decryption AES encryption round AES pros \u2022 Most operations can be combined into XOR and table lookups - hence very fast & efficient Take-home Exercises \u2022 Find an AES API to encrypt a text (A), then decrypt it and check whether the original text (A) equals the decrypted text (B). Whether A = B? \u2022 Compare the decryption time with different key lengths, and with DES and 3DES. \u2022 Suggestions: find a large A file. Run decryption a couple of times and take the average. Reading materials \u2022 FIPS 197, Advanced Encryption Standard (AES) (nist.gov) WPEC 2024: NIST Workshop on Privacy- Enhancing Cryptography \u2022 Time: September 24\u201326, 2024 \u2022 Free to register \u2022 Virtual conference via Zoom \u2022 https://csrc.nist.gov/events/2024/wpec2024 Feistel Encryption and Decryption DES encryption \u2022 64 bits plaintext \u2022 56 bits effective key length DES Weakness \u2022 short length key (56 bits) is not secure enough. Brutal force search takes short time. Triple DES (3DES) Decrypting with the wrong key will further convolute the output 3DES \u2022 Triple DES with three different keys \u2013 brute-force complexity 2168 \u2022 3DES is the FIPS-approved symmetric encryption algorithm \u2022 Weakness: slow speed for encryption FIPS \u2013 Federal Information Processing Standards. The United States' Federal Information Processing Standards are publicly announced standards developed by the National Institute of Standards and Technology for use in computer systems by non-military American government agencies and government contractors AES \u2022 clearly a replacement for DES was needed \u2022 have theoretical attacks that can break it \u2022 have demonstrated exhaustive key search attacks \u2022 can use Triple-DES \u2013 but slow with small blocks \u2022 US NIST issued call for ciphers in 1997 \u2022 15 candidates accepted in Jun 98 \u2022 5 were short-listed in Aug-99 \u2022 Rijndael was selected as the AES in Oct-2000 \u2022 issued as FIPS PUB 197 standard in Nov-2001 Criteria to evaluate AES \u2022 General security \u2022 Software implementations \u2022 Restricted-space environments \u2022 Hardware implementations \u2022 Attacks on implementations \u2022 Encryption versus decryption \u2022 Key agility \u2022 Other versatility and flexibility \u2022 Potential for instruction-level parallelism Cryptographic Standards and Guidelines | CSRC (nist.gov) AES Specification \u2022 symmetric block cipher \u2022 128-bit data, 128/192/256-bit keys \u2022 stronger & faster than Triple-DES \u2022 provide full specification & design details \u2022 both C & Java implementations \u2022 NIST have released all submissions & unclassified analyses https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards- and-Guidelines/documents/aes-development/Rijndael-ammended.pdf The AES Cipher - Rijndael \u2022 an iterative rather than feistel cipher \u2022 treats data in 4 groups of 4 bytes \u2022 operates an entire block in every round \u2022 designed to be: \u2022 resistant against known-plaintext attacks \u2022 speed and code compactness on many CPUs \u2022 design simplicity Rijndael \u2022 processes data as 4 groups of 4 bytes (state) = 128 bits \u2022 has 10/12/14 rounds in which state undergoes: \u2022 byte substitution (1 S-box used on every byte) \u2022 shift rows (permute bytes row by row) \u2022 mix columns (alter each byte in a column as a function of all of the bytes in the column) \u2022 add round key (XOR state with key material) \u2022 128-bit keys \u2013 10 rounds, 192-bit keys \u2013 12 rounds, 256-bit keys \u2013 14 rounds Symmetric Block Encryption Block cipher \u2022 the most commonly used symmetric encryption algorithms \u2022 input: fixed-size blocks (Typically 64, 128 bit blocks), output: equal size blocks \u2022 provide secrecy and/or authentication services \u2022 Data Encryption Standard (DES), triple DES (3DES), and the Advanced Encryption Standard (AES)s \u2022 Usually employ Feistel structure Feistel Cipher Structure Feistel Cipher Structure \u2022 most symmetric block ciphers are based on a Feistel Cipher Structure \u2022 based on the two primitive cryptographic operations \u2022 substitution (S-box) \u2022 permutation (P-box) \u2022 provide confusion and diffusion of message Feistel Cipher Structure \u2022 Horst Feistel devised the feistel cipher in the 1973 \u2022 based on concept of invertible product cipher \u2022 partitions input block into two halves \u2022 process through multiple rounds which \u2022 perform a substitution on left data half \u2022 based on round function of right half & subkey \u2022 then have permutation swapping halves \u2022 implements Shannon\u2019s substitution-permutation network concept Feistel Encryption and Decryption A strong encryption algorithm attacker encryption algorithm plaintext / enquiry cyphertext / response Secure Encryption Scheme \u2022 Unconditional security \u2022 no matter how much computer power is available, the cipher cannot be broken since the ciphertext provides insufficient information to uniquely determine the corresponding plaintext \u2022 Computational security \u2022 the cost of breaking the cipher exceeds the value of the encrypted information; \u2022 or the time required to break the cipher exceeds the useful lifetime of the information Desired characteristics \u2022 Cipher needs to completely obscure statistical properties of original message \u2022 more practically Shannon suggested combining elements to obtain: \u2022 Confusion \u2013 how does changing a bit of the key affect the ciphertext? \u2022 Diffusion \u2013 how does changing one bit of the plaintext affect the ciphertext? confusion ciphertext plaintext diffusion Ways to achieve \u2022 Symmetric Encryption: \u2022 substitution / transposition / hybrid \u2022 Asymmetric Encryption: \u2022 Mathematical hardness - problems that are efficient to compute in one direction, but inefficient to reverse by the attacker \u2022 Examples: Modular arithmetic, factoring, discrete logarithm problem, Elliptic Logs over Elliptic Curves Two basic types \u2022 Block Ciphers \u2022 Typically 64, 128 bit blocks \u2022 A k-bit plaintext block maps to a k-bit ciphertext block \u2022 Usually employ Feistel structure \u2022 Stream Ciphers \u2022 A key is used to generate a stream of pseudo-random bits \u2013 key stream \u2022 Just XOR plaintext bits with the key stream for encryption \u2022 For decryption generate the key stream and XOR with the ciphertext! Symmetric Block Encryption Block cipher \u2022 the most commonly used symmetric encryption algorithms \u2022 input: fixed-size blocks (Typically 64, 128 bit blocks), output: equal size blocks \u2022 provide secrecy and/or authentication services \u2022 Data Encryption Standard (DES), triple DES (3DES), and the Advanced Encryption Standard (AES)s \u2022 Usually employ Feistel structure Feistel Cipher Structure Feistel Cipher Structure \u2022 most symmetric block ciphers are based on a Feistel Cipher Structure \u2022 based on the two primitive cryptographic operations \u2022 substitution (S-box) \u2022 permutation (P-box) \u2022 provide confusion and diffusion of message Feistel Cipher Structure \u2022 Horst Feistel devised the feistel cipher in the 1973 \u2022 based on concept of invertible product cipher \u2022 partitions input block into two halves \u2022 process through multiple rounds which \u2022 perform a substitution on left data half \u2022 based on round function of right half & subkey \u2022 then have permutation swapping halves \u2022 implements Shannon\u2019s substitution-permutation network concept Feistel Encryption and Decryption Symmetric Encryption and Message Confidentiality Chapter 2 Model for network security Model for network security \u2022 Using this model requires us to: \u2022 design a suitable algorithm for the security transformation \u2022 generate the secret information (keys) used by the algorithm \u2022 develop methods to distribute and share the secret information \u2022 specify a protocol enabling the principals to use the transformation and secret information for a security service Symmetric Encryption Principles Symmetric encryption \u2022 Sender and recipient share a common/same key \u2022 Was the only type of cryptography, prior to invention of public-key in 1970\u2019s Simplified model of symmetric encryption Symmetric encryption \u2022 Has five ingredients \u2022 Plaintext: the original message or data \u2022 Encryption algorithm: performs various substitutions and transformations on the plaintext \u2022 Secret key \u2022 Ciphertext: the coded message \u2022 Decryption algorithm: takes the ciphertext and the same secret key and produces the original plaintext Other basic terminology \u2022 cipher - algorithm for transforming plaintext to ciphertext \u2022 encipher (encrypt) - converting plaintext to ciphertext \u2022 decipher (decrypt) - recovering plaintext from ciphertext \u2022 cryptography - study of encryption principles/methods \u2022 cryptanalysis (codebreaking) - the study of principles/ methods of deciphering ciphertext without knowing key Requirements \u2022 Two requirements for secure use of symmetric encryption: \u2022 a strong encryption algorithm \u2022 a secret key known only to sender / receiver Y = EK(X) X = DK(Y) \u2022 assume encryption algorithm is known \u2022 the security of symmetric encryption depends on the secrecy of the key \u2022 implies a secure channel to distribute key A strong encryption algorithm attacker encryption algorithm plaintext / enquiry cyphertext / response TA & Grader \u2022 TA Name: Faiyaz, Amir (Project, Review & Quiz) \u2022 Email: afaiyaz@ttu.edu \u2022 Reminder: Submit the names and emails of your group members to FALL 2024 CS5342 PROJECT GROUP NAMES.xlsx \u2022 Grader Name: Han, Namgyu (Homework, Quiz, Exam grading) \u2022 Email: Namgyu.Han@ttu.edu Know Your Threat Model \u2022 Threat model: A model of who your attacker is and what resources they have \u2022 One of the best ways to counter an attacker is to attack their reasons Story\u2026 \u2022 The bear race \u2022 Takeaway: Even if a defense is not perfect, it is important to always stay on top of best security measures I don\u2019t have to outrun the bear. I just have to outrun you Human Factors \u2022 The users \u2022 Users like convenience (ease of use) \u2022 If a security system is unusable, it will be unused \u2022 Users will find way to subvert security systems if it makes their lives easier \u2022 The programmers \u2022 Programmers make mistakes \u2022 Programmers use tools that allow them to make mistakes (e.g. C and C++) \u2022 Everyone else \u2022 Social engineering attacks exploit other people\u2019s trust and access for personal gain Design in security from the start \u2022 When building a new system, include security as part of the design considerations rather than patching it after the fact \u2022 A lot of systems today were not designed with security from the start, resulting in patches that don\u2019t fully fix the problem! \u2022 Keep these security principles in mind whenever you write code! Security Services and Mechanisms Supplementary materials \u2022 Internet Security Glossary, v2 \u2013 produced by Internet Society (ISOC) https://datatracker.ietf.org/doc/html/rfc4949 \u2022 X.800 \u2013 OSI network security https://www.itu.int/rec/dologin_pub.asp?lang=f&id=T-REC-X.800- 199103-I!!PDF-E&type=items Summary for Chapter 1 \u2022 Have learned: \u2022 Security requirements \u2022 Attack models \u2022 X.800 secure architecture, security services, mechanisms Review Questions \u2022 William Stallings (WS), \u201cNetwork Security Essentials\u201d, 6th Global Edition \u2022 RQ 1.1 - 1.3 \u2022 Prob 1.5 Security attack \u2022 Definition: any action that compromises the security of information owned by an organization \u2022 Two types of security attacks \u2022 Passive attack \u2022 Active attack Passive attack \u2022 i.e. eavesdropping on or monitoring of transmissions \u2022 Goal: obtain information being transmitted \u2022 release of message contents \u2022 traffic analysis \u2013 a promiscuous sniffer \u2022 Very difficult to detect \u2013 no alteration of the data \u2022 But easy to prevent, why? Active attack \u2022 active attack includes: \u2022 replay \u2022 Modification of messages \u2022 Denial of service \u2022 Masquerade Example: two points communication \u2022 Generic types of attacks Eavedropping Example of modification attack in 6LoWPAN Example: a group of attackers Know Your Threat Model \u2022 Threat model: A model of who your attacker is and what resources they have \u2022 One of the best ways to counter an attacker is to attack their reasons Example: adversary model \u2022 \u201cThe adversary is assumed to be intelligent and has limited number of resources. Before capturing the nodes, it exploits the various vulnerabilities of the networks. It knows the topology of the network, routing information. It aims to capture the sink node so as to disrupt the whole traffic. If it is not able to capture the sink node, it will capture the nearby nodes of the sink. It tries to disrupt the whole traffic of the network with minimum number of captured nodes. It is also assumed that the adversary tends to attack more on the nodes closer to the data sink than nodes that are far away\u201d No class on Wednesday \u2022 No class on Wednesday (Sept 18, 2024) due to the Job fair. Wish you good luck! \u2022 Reminder to form a project group by Sept. 9th, 2024 Project \u2022 Task1: OnDemand Professor Q&A Bot \u2022 Your task is to build a Q&A Bot over private data that answers questions about the network security course using the open-source alternatives to ChatGPT that can be run on your local machine. Data privacy can be compromised when sending data over the internet, so it is mandatory to keep it on your local system. \u2022 Your Q&A Bot should be able to understand user questions and provide appropriate answers from the local database, then the citations should be added (must be accomplished) if the response is from the internet, then the web references should be added. \u2022 Train your bot using network security lecture slides, network security textbook, and the Internet. \u2022 By using Wireshark capture data for Step 4's of the LLM workflow shown in Figure 1. Provide detailed explanations of the trace data. Also, Maintain a record of Step 1's prompt and its mapping to the trace data in Step 4's. \u2022 Task2: Quiz Bot \u2022 Your task is to build a quiz bot based on a network security course using the open-source alternatives to ChatGPT that can be run on your local machine. Data privacy can be compromised when sending data over the internet, so it is mandatory to keep it on your local system. \u2022 Two types of questions should be offered by the bot: randomly generated questions and specific topic questions and the answers should be pulled from the network security database. Train your bot using network security quizzes, lecture slides, network security textbook, and the Internet. \u2022 The quiz must include multiple-choice questions, true/false questions, and open-ended questions. \u2022 Finally, the bot should be able to provide feedback on the user's answers. Outline \u2022 Review \u2022 OSI Security Architecture \u2022 Attack model OSI Security Architecture OSI Security Architecture \u2022 International Telecommunication Union \u2013 Telecommunication (ITU-T) recommends X.800 \u2022 Security Architecture for Open Systems Interconnection (OSI) \u2022 Defines a systematic way of defining and providing security requirements \u2022 Used by IT managers and vendors in their products Security attacks Security mechanisms Security services a process (or a device incorporating such a process) to detect, prevent, or recover from an attack enhances the security of the data processing systems and the information transfers, such as policies Other Security Architectures \u2022 NIST, Cybersecurity Framework (CSF) \u2022 https://www.nist.gov/cyberframework \u2022 VIRTUAL WORKSHOP #2 | February 15, 2023 (9:00 AM \u2013 5:30 PM EST). Discuss potential significant updates to the CSF \u2022 https://www.nist.gov/news-events/events/2023/02/journey-nist-cybersecurity- framework-csf-20-workshop-2 \u2022 OWASP - Open Web Application Security Project \u2022 Web application security \u2022 OWASP Application Security Verification Standard (ASVS) - https://owasp.org/www-project-application-security-verification-standard/ \u2022 OWASP Web Security Testing - https://owasp.org/www-project-web-security-testing- guide/ \u2022 OWASP foundation Security attack \u2022 Definition: any action that compromises the security of information owned by an organization \u2022 Two types of security attacks \u2022 Passive attack \u2022 Active attack Network Security Introduction Chapter 1 Learning Objective \u2022 Introduce the security requirements \u2022 confidentiality \u2022 integrity \u2022 availability \u2022 Describe the X.800 security architecture for OSI Network Security Requirements Computer Network Security \u2022 Definition: The protection afforded to an automated information system in order to attain the application objectives to preserving the integrity, availability, and confidentiality of information system resources (includes hardware, software, firmware, information/data, and telecommunications). - NIST Computer Security Handbook Confidentiality \u2022 Data confidentiality: Assures that private or confidential information is not made available or disclosed to unauthorized individuals; \u2022 Privacy: Assures that individual's control or influence what information related to them may be collected and stored and by whom and to whom that information may be disclosed \u2022 i.e., student grade information Integrity \u2022 Data integrity: Assures that data (both stored and in transmitted packets) and programs are changed only in a specified and authorized manner; \u2022 System integrity: Assures that a system performs its intended function in an unimpaired manner, free from deliberate or inadvertent unauthorized manipulation of the system \u2022 i.e., a hospital patient\u2019s allergy information Availability \u2022 Availability: Assures that systems work promptly, and service is not denied to authorized users, ensuring timely and reliable access to and use of information \u2022 i.e., denial of service attack Other security requirements \u2022 Authenticity \u2022 Accountability \u2022 tracible data source, \u2022 fault isolation \u2022 intrusion detection and prevention, \u2022 recovery and legal action \u2022 system must keep records of their activities to permit later forensic analysis to trace security breaches or to aid in transaction disputes Question \u2022 What security requirements does a blockchain system have achieved? A Hyperledger \n\nQuestion: list main NS topics\nAnswer:",
    "llm_response": "This is a simulated LLM response based on the context."
}